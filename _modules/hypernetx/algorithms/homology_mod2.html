<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>hypernetx.algorithms.homology_mod2 &mdash; HyperNetX 2.0.5 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
        <script src="../../../_static/clipboard.min.js"></script>
        <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            HyperNetX
              <img src="../../../_static/hnx_logo_smaller.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../overview/index.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installing HyperNetX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../core.html">HyperNetX Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../hypergraph101.html">A Gentle Introduction to Hypergraph Mathematics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../hypconstructors.html">Hypergraph Constructors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../widget.html">Visualization Widget</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modularity.html">Algorithms: Modularity and Clustering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../publications.html">Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">HyperNetX</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">hypernetx.algorithms.homology_mod2</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for hypernetx.algorithms.homology_mod2</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Homology and Smith Normal Form</span>
<span class="sd">==============================</span>
<span class="sd">The purpose of computing the Homology groups for data generated</span>
<span class="sd">hypergraphs is to identify data sources that correspond to interesting</span>
<span class="sd">features in the topology of the hypergraph.</span>

<span class="sd">The elements of one of these Homology groups are generated by $k$</span>
<span class="sd">dimensional cycles of relationships in the original data that are not</span>
<span class="sd">bound together by higher order relationships. Ideally, we want the</span>
<span class="sd">briefest description of these cycles; we want a minimal set of</span>
<span class="sd">relationships exhibiting interesting cyclic behavior. This minimal set</span>
<span class="sd">will be a bases for the Homology group.</span>

<span class="sd">The cyclic relationships in the data are discovered using a **boundary</span>
<span class="sd">map** represented as a matrix. To discover the bases we compute the</span>
<span class="sd">**Smith Normal Form** of the boundary map.</span>

<span class="sd">Homology Mod2</span>
<span class="sd">-------------</span>
<span class="sd">This module computes the homology groups for data represented as an</span>
<span class="sd">abstract simplicial complex with chain groups $\{C_k\}$ and $Z_2$ additions.</span>
<span class="sd">The boundary matrices are represented as rectangular matrices over $Z_2$.</span>
<span class="sd">These matrices are diagonalized and represented in Smith</span>
<span class="sd">Normal Form. The kernel and image bases are computed and the Betti</span>
<span class="sd">numbers and homology bases are returned.</span>

<span class="sd">Methods for obtaining SNF for Z/2Z are based on Ferrario&#39;s work:</span>
<span class="sd">http://www.dlfer.xyz/post/2016-10-27-smith-normal-form/</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">hypernetx</span> <span class="k">as</span> <span class="nn">hnx</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">hypernetx</span> <span class="kn">import</span> <span class="n">HyperNetXError</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_matrix</span>


<div class="viewcode-block" id="kchainbasis"><a class="viewcode-back" href="../../../algorithms/algorithms.html#algorithms.kchainbasis">[docs]</a><span class="k">def</span> <span class="nf">kchainbasis</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the set of k dimensional cells in the abstract simplicial</span>
<span class="sd">    complex associated with the hypergraph.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h : hnx.Hypergraph</span>
<span class="sd">    k : int</span>
<span class="sd">        dimension of cell</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : list</span>
<span class="sd">        an ordered list of kchains represented as tuples of length k+1</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    hnx.hypergraph.toplexes</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Method works best if h is simple [Berge], i.e. no edge contains another and there are no duplicate edges (toplexes).</span>
<span class="sd">    - Hypergraph node uids must be sortable.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>

    <span class="n">kchains</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">h</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="n">en</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">en</span><span class="p">)</span> <span class="o">==</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">kchains</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">en</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">en</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">kchains</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">en</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">kchains</span><span class="p">))</span></div>


<div class="viewcode-block" id="bkMatrix"><a class="viewcode-back" href="../../../algorithms/algorithms.html#algorithms.bkMatrix">[docs]</a><span class="k">def</span> <span class="nf">bkMatrix</span><span class="p">(</span><span class="n">km1basis</span><span class="p">,</span> <span class="n">kbasis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the boundary map from $C_{k-1}$-basis to $C_k$ basis with</span>
<span class="sd">    respect to $Z_2$</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    km1basis : indexable iterable</span>
<span class="sd">        Ordered list of $k-1$ dimensional cell</span>
<span class="sd">    kbasis : indexable iterable</span>
<span class="sd">        Ordered list of $k$ dimensional cells</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bk : np.array</span>
<span class="sd">        boundary matrix in $Z_2$ stored as boolean</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">km1basis</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">kbasis</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">kbasis</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cell</span><span class="p">)):</span>
            <span class="n">face</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">cell</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">km1basis</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">face</span><span class="p">)</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">kbasis</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
            <span class="n">bk</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">bk</span></div>


<span class="k">def</span> <span class="nf">_rswap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Swaps ith and jth row of copy of S</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    i : int</span>
<span class="sd">    j : int</span>
<span class="sd">    S : np.array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    N : np.array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="n">row</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span>
    <span class="k">return</span> <span class="n">N</span>


<span class="k">def</span> <span class="nf">_cswap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Swaps ith and jth column of copy of S</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    i : int</span>
<span class="sd">    j : int</span>
<span class="sd">    S : np.array</span>
<span class="sd">        matrix</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    N : np.array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">_rswap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">N</span>


<div class="viewcode-block" id="swap_rows"><a class="viewcode-back" href="../../../algorithms/algorithms.html#algorithms.swap_rows">[docs]</a><span class="k">def</span> <span class="nf">swap_rows</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Swaps ith and jth row of each matrix in args</span>
<span class="sd">    Returns a list of new matrices</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    i : int</span>
<span class="sd">    j : int</span>
<span class="sd">    args : np.arrays</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        list of copies of args with ith and jth row swapped</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">M</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_rswap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">M</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="swap_columns"><a class="viewcode-back" href="../../../algorithms/algorithms.html#algorithms.swap_columns">[docs]</a><span class="k">def</span> <span class="nf">swap_columns</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Swaps ith and jth column of each matrix in args</span>
<span class="sd">    Returns a list of new matrices</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    i : int</span>
<span class="sd">    j : int</span>
<span class="sd">    args : np.arrays</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        list of copies of args with ith and jth row swapped</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">M</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_cswap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">M</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="add_to_row"><a class="viewcode-back" href="../../../algorithms/algorithms.html#algorithms.add_to_row">[docs]</a><span class="k">def</span> <span class="nf">add_to_row</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replaces row i with logical xor between row i and j</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : np.array</span>
<span class="sd">    i : int</span>
<span class="sd">        index of row being altered</span>
<span class="sd">    j : int</span>
<span class="sd">        index of row being added to altered</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    N : np.array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">N</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">N</span></div>


<div class="viewcode-block" id="add_to_column"><a class="viewcode-back" href="../../../algorithms/algorithms.html#algorithms.add_to_column">[docs]</a><span class="k">def</span> <span class="nf">add_to_column</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replaces column i (of M) with logical xor between column i and j</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : np.array</span>
<span class="sd">        matrix</span>
<span class="sd">    i : int</span>
<span class="sd">        index of column being altered</span>
<span class="sd">    j : int</span>
<span class="sd">        index of column being added to altered</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    N : np.array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">add_to_row</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span></div>


<div class="viewcode-block" id="logical_dot"><a class="viewcode-back" href="../../../algorithms/algorithms.html#algorithms.logical_dot">[docs]</a><span class="k">def</span> <span class="nf">logical_dot</span><span class="p">(</span><span class="n">ar1</span><span class="p">,</span> <span class="n">ar2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the boolean equivalent of the dot product mod 2 on two 1-d arrays of</span>
<span class="sd">    the same length.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ar1 : numpy.ndarray</span>
<span class="sd">        1-d array</span>
<span class="sd">    ar2 : numpy.ndarray</span>
<span class="sd">        1-d array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    : bool</span>
<span class="sd">        boolean value associated with dot product mod 2</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    HyperNetXError</span>
<span class="sd">        If arrays are not of the same length an error will be raised.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ar1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ar2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">HyperNetXError</span><span class="p">(</span><span class="s2">&quot;logical_dot requires two 1-d arrays of the same length&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">ar1</span><span class="p">,</span> <span class="n">ar2</span><span class="p">))</span></div>


<div class="viewcode-block" id="logical_matmul"><a class="viewcode-back" href="../../../algorithms/algorithms.html#algorithms.logical_matmul">[docs]</a><span class="k">def</span> <span class="nf">logical_matmul</span><span class="p">(</span><span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the boolean equivalent of matrix multiplication mod 2 on two</span>
<span class="sd">    binary arrays stored as type boolean</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mat1 : np.ndarray</span>
<span class="sd">        2-d array of boolean values</span>
<span class="sd">    mat2 : np.ndarray</span>
<span class="sd">        2-d array of boolean values</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mat : np.ndarray</span>
<span class="sd">        boolean matrix equivalent to the mod 2 matrix multiplication of the</span>
<span class="sd">        matrices as matrices over Z/2Z</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    HyperNetXError</span>
<span class="sd">        If inner dimensions are not equal an error will be raised.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">L1</span><span class="p">,</span> <span class="n">R1</span> <span class="o">=</span> <span class="n">mat1</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">L2</span><span class="p">,</span> <span class="n">R2</span> <span class="o">=</span> <span class="n">mat2</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">R1</span> <span class="o">!=</span> <span class="n">L2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">HyperNetXError</span><span class="p">(</span>
            <span class="s2">&quot;logical_matmul called for matrices with inner dimensions mismatched&quot;</span>
        <span class="p">)</span>

    <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">L1</span><span class="p">,</span> <span class="n">R2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">mat2T</span> <span class="o">=</span> <span class="n">mat2</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mat1</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">R2</span><span class="p">):</span>
                <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">logical_dot</span><span class="p">(</span><span class="n">mat1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mat2T</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">R2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mat</span></div>


<div class="viewcode-block" id="matmulreduce"><a class="viewcode-back" href="../../../algorithms/algorithms.html#algorithms.matmulreduce">[docs]</a><span class="k">def</span> <span class="nf">matmulreduce</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively applies a &#39;logical multiplication&#39; to a list of boolean arrays.</span>

<span class="sd">    For arr = [arr[0],arr[1],arr[2]...arr[n]] returns product arr[0]arr[1]...arr[n]</span>
<span class="sd">    If reverse = True, returns product arr[n]arr[n-1]...arr[0]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : list of np.array</span>
<span class="sd">        list of nxm matrices represented as np.array</span>
<span class="sd">    reverse : bool, optional</span>
<span class="sd">        order to multiply the matrices</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    P : np.array</span>
<span class="sd">        Product of matrices in the list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
        <span class="n">items</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">items</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">items</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">logical_matmul</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">P</span></div>


<div class="viewcode-block" id="logical_matadd"><a class="viewcode-back" href="../../../algorithms/algorithms.html#algorithms.logical_matadd">[docs]</a><span class="k">def</span> <span class="nf">logical_matadd</span><span class="p">(</span><span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the boolean equivalent of matrix addition mod 2 on two</span>
<span class="sd">    binary arrays stored as type boolean</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mat1 : np.ndarray</span>
<span class="sd">        2-d array of boolean values</span>
<span class="sd">    mat2 : np.ndarray</span>
<span class="sd">        2-d array of boolean values</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mat : np.ndarray</span>
<span class="sd">        boolean matrix equivalent to the mod 2 matrix addition of the</span>
<span class="sd">        matrices as matrices over Z/2Z</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    HyperNetXError</span>
<span class="sd">        If dimensions are not equal an error will be raised.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">S1</span> <span class="o">=</span> <span class="n">mat1</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">S2</span> <span class="o">=</span> <span class="n">mat2</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">S1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">S1</span> <span class="o">!=</span> <span class="n">S2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">HyperNetXError</span><span class="p">(</span>
            <span class="s2">&quot;logical_matadd called for matrices with different dimensions&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">S1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">S1</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">mat</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">mat1</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">mat2</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">S1</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">jdx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">S1</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">mat</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">jdx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">mat1</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">jdx</span><span class="p">],</span> <span class="n">mat2</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">jdx</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">mat</span></div>


<span class="c1"># Convenience methods for computing Smith Normal Form</span>
<span class="c1"># All of these operations have themselves as inverses</span>


<span class="k">def</span> <span class="nf">_sr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">swap_rows</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_sc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">swap_columns</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_ar</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">add_to_row</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">add_to_row</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_ac</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">add_to_column</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">add_to_column</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_next_pivot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines the first r,c indices in the submatrix of M starting</span>
<span class="sd">    with row s1 and column s2 index (row,col) that is nonzero,</span>
<span class="sd">    if it exists.</span>

<span class="sd">    Search starts with the s2th column and looks for the first nonzero</span>
<span class="sd">    s1 row. If none is found, search continues to the next column and so</span>
<span class="sd">    on.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : np.array</span>
<span class="sd">        matrix represented as np.array</span>
<span class="sd">    s1 : int</span>
<span class="sd">        index of row position to start submatrix of M</span>
<span class="sd">    s2 : int, optional, default = s1</span>
<span class="sd">        index of column position to start submatrix of M</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (r,c) : tuple of int or None</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># find the next nonzero pivot to put in s,s spot for Smith Normal Form</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">s2</span><span class="p">:</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">M</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span>


<div class="viewcode-block" id="smith_normal_form_mod2"><a class="viewcode-back" href="../../../algorithms/algorithms.html#algorithms.smith_normal_form_mod2">[docs]</a><span class="k">def</span> <span class="nf">smith_normal_form_mod2</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the invertible transformation matrices needed to compute the</span>
<span class="sd">    Smith Normal Form of M modulo 2</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : np.array</span>
<span class="sd">        a rectangular matrix with data type bool</span>
<span class="sd">    track : bool</span>
<span class="sd">        if track=True will print out the transformation as Z/2Z matrix as it</span>
<span class="sd">        discovers L[i] and R[j]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    L, R, S, Linv : np.arrays</span>
<span class="sd">        LMR = S is the Smith Normal Form of the matrix M.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    Given a mxn matrix $M$ with</span>
<span class="sd">    entries in $Z_2$ we start with the equation: $L M R = S$, where</span>
<span class="sd">    $L = I_m$, and $R=I_n$ are identity matrices and $S = M$. We</span>
<span class="sd">    repeatedly apply actions to the left and right side of the equation</span>
<span class="sd">    to transform S into a diagonal matrix.</span>
<span class="sd">    For each action applied to the left side we apply its inverse</span>
<span class="sd">    action to the right side of I_m to generate $L^{-1}$.</span>
<span class="sd">    Finally we verify:</span>
<span class="sd">    $L M R = S$ and  $LLinv = I_m$.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">S</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">dimL</span><span class="p">,</span> <span class="n">dimR</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># initialize left and right transformations with identity matrices</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dimL</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dimR</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">Linv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dimL</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">dimL</span><span class="p">,</span> <span class="n">dimR</span><span class="p">)):</span>
        <span class="c1"># Find index pair (rdx,cdx) with value 1 in submatrix M[s:,s:]</span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="n">_get_next_pivot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pivot</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rdx</span><span class="p">,</span> <span class="n">cdx</span> <span class="o">=</span> <span class="n">pivot</span>
        <span class="c1"># Swap rows and columns as needed so that 1 is in the s,s position</span>
        <span class="k">if</span> <span class="n">rdx</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">S</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">_sr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
            <span class="n">Linv</span> <span class="o">=</span> <span class="n">swap_columns</span><span class="p">(</span><span class="n">rdx</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">Linv</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cdx</span> <span class="o">&gt;</span> <span class="n">s</span><span class="p">:</span>
            <span class="n">S</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">_sc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">cdx</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
        <span class="c1"># add sth row to every row with 1 in sth column &amp; sth column to every column with 1 in sth row</span>
        <span class="n">row_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dimL</span><span class="p">)</span> <span class="k">if</span> <span class="n">S</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">rdx</span> <span class="ow">in</span> <span class="n">row_indices</span><span class="p">:</span>
            <span class="n">S</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">_ar</span><span class="p">(</span><span class="n">rdx</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
            <span class="n">Linv</span> <span class="o">=</span> <span class="n">add_to_column</span><span class="p">(</span><span class="n">Linv</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">rdx</span><span class="p">)</span>
        <span class="n">column_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">jdx</span> <span class="k">for</span> <span class="n">jdx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dimR</span><span class="p">)</span> <span class="k">if</span> <span class="n">S</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">jdx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">cdx</span> <span class="ow">in</span> <span class="n">column_indices</span><span class="p">:</span>
            <span class="n">S</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">_ac</span><span class="p">(</span><span class="n">cdx</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Linv</span></div>


<div class="viewcode-block" id="reduced_row_echelon_form_mod2"><a class="viewcode-back" href="../../../algorithms/algorithms.html#algorithms.reduced_row_echelon_form_mod2">[docs]</a><span class="k">def</span> <span class="nf">reduced_row_echelon_form_mod2</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the invertible transformation matrices needed to compute</span>
<span class="sd">    the reduced row echelon form of M modulo 2</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : np.array</span>
<span class="sd">        a rectangular matrix with elements in $Z_2$</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    L, S, Linv : np.arrays</span>
<span class="sd">        LM = S where S is the reduced echelon form of M</span>
<span class="sd">        and M = LinvS</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">dimL</span><span class="p">,</span> <span class="n">dimR</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># method with numpy</span>
    <span class="n">Linv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dimL</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dimL</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">s2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">s2</span> <span class="o">&lt;=</span> <span class="n">dimR</span> <span class="ow">and</span> <span class="n">s1</span> <span class="o">&lt;=</span> <span class="n">dimL</span><span class="p">:</span>
        <span class="c1"># Find index pair (rdx,cdx) with value 1 in submatrix M[s1:,s2:]</span>
        <span class="c1"># look for the first 1 in the s2 column</span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="n">_get_next_pivot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">pivot</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">L</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Linv</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rdx</span><span class="p">,</span> <span class="n">cdx</span> <span class="o">=</span> <span class="n">pivot</span>
            <span class="k">if</span> <span class="n">rdx</span> <span class="o">&gt;</span> <span class="n">s1</span><span class="p">:</span>
                <span class="c1"># Swap rows as needed so that 1 leads the row</span>
                <span class="n">S</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">_sr</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
                <span class="n">Linv</span> <span class="o">=</span> <span class="n">swap_columns</span><span class="p">(</span><span class="n">rdx</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">Linv</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># add s1th row to every nonzero row</span>
            <span class="n">row_indices</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dimL</span><span class="p">)</span> <span class="k">if</span> <span class="n">idx</span> <span class="o">!=</span> <span class="n">s1</span> <span class="ow">and</span> <span class="n">S</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="n">cdx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="p">]</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">row_indices</span><span class="p">:</span>
                <span class="n">S</span><span class="p">,</span> <span class="n">L</span> <span class="o">=</span> <span class="n">_ar</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
                <span class="n">Linv</span> <span class="o">=</span> <span class="n">add_to_column</span><span class="p">(</span><span class="n">Linv</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
            <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cdx</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">L</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Linv</span></div>


<div class="viewcode-block" id="boundary_group"><a class="viewcode-back" href="../../../algorithms/algorithms.html#algorithms.boundary_group">[docs]</a><span class="k">def</span> <span class="nf">boundary_group</span><span class="p">(</span><span class="n">image_basis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a csr_matrix with rows corresponding to the elements of the</span>
<span class="sd">    group  generated by image basis over $\mathbb{Z}_2$</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image_basis : numpy.ndarray or scipy.sparse.csr_matrix</span>
<span class="sd">        2d-array of basis elements</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">     : scipy.sparse.csr_matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image_basis</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        This method is inefficient for large image bases.</span>
<span class="s2">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">image_basis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="n">image_basis</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">itm</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="n">dim</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">itm</span> <span class="o">*</span> <span class="n">image_basis</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span></div>


<span class="k">def</span> <span class="nf">_compute_matrices_for_snf</span><span class="p">(</span><span class="n">bd</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper method for smith normal form decomposition for boundary maps</span>
<span class="sd">    associated to chain complex</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bd : dict</span>
<span class="sd">        dict of k-boundary matrices keyed on dimension of domain</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    L,R,S,Linv : dict</span>
<span class="sd">        dict of matrices ranging over krange</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Linv</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">kdx</span> <span class="ow">in</span> <span class="n">bd</span><span class="p">:</span>
        <span class="n">L</span><span class="p">[</span><span class="n">kdx</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="n">kdx</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="n">kdx</span><span class="p">],</span> <span class="n">Linv</span><span class="p">[</span><span class="n">kdx</span><span class="p">]</span> <span class="o">=</span> <span class="n">smith_normal_form_mod2</span><span class="p">(</span><span class="n">bd</span><span class="p">[</span><span class="n">kdx</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Linv</span>


<span class="k">def</span> <span class="nf">_get_krange</span><span class="p">(</span><span class="n">max_dim</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper method to compute range of appropriate k dimensions for homology</span>
<span class="sd">    computations given k and the max dimension of a simplicial complex</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">krange</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_dim</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Only kth simplicial homology groups for k&gt;0 may be computed.&quot;</span>
                <span class="s2">&quot;If you are interested in k=0, compute the number connected components.&quot;</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">max_dim</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;No simplices of dim </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> exist. k adjusted to max dim.&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">krange</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">([</span><span class="n">k</span><span class="p">,</span> <span class="n">max_dim</span><span class="p">])]</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Please enter krange as a positive integer or list of integers: [&lt;min k&gt;,&lt;max k&gt;] inclusive.&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;k must be an integer or a list of two integers [min,max] with min &lt;=max&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">krange</span> <span class="o">=</span> <span class="n">k</span>

    <span class="k">if</span> <span class="n">krange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_dim</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;No simplices of dim </span><span class="si">{</span><span class="n">krange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> exist. Range adjusted to max dim.&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">krange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_dim</span>
    <span class="k">if</span> <span class="n">krange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Only kth simplicial homology groups for k&gt;0 may be computed.&quot;</span>
            <span class="s2">&quot;If you are interested in k=0, compute the number of connected components.&quot;</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">krange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">krange</span>


<div class="viewcode-block" id="chain_complex"><a class="viewcode-back" href="../../../algorithms/algorithms.html#algorithms.chain_complex">[docs]</a><span class="k">def</span> <span class="nf">chain_complex</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the k-chains and k-boundary maps required to compute homology</span>
<span class="sd">    for all values in k</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h : hnx.Hypergraph</span>
<span class="sd">    k : int or list of length 2, optional, default=None</span>
<span class="sd">        k must be an integer greater than 0 or a list of</span>
<span class="sd">        length 2 indicating min and max dimensions to be</span>
<span class="sd">        computed. eg. if k = [1,2] then 0,1,2,3-chains</span>
<span class="sd">        and boundary maps for k=1,2,3 will be returned,</span>
<span class="sd">        if None than k = [1,max dimension of edge in h]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    C, bd : dict</span>
<span class="sd">        C is a dictionary of lists</span>
<span class="sd">        bd is a dictionary of numpy arrays</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">max_dim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">h</span><span class="o">.</span><span class="n">edges</span><span class="p">()])</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">krange</span> <span class="o">=</span> <span class="n">_get_krange</span><span class="p">(</span><span class="n">max_dim</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">krange</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="c1"># Compute chain complex</span>

    <span class="n">C</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">C</span><span class="p">[</span><span class="n">krange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">kchainbasis</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">krange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">bd</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">kdx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">krange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">krange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">C</span><span class="p">[</span><span class="n">kdx</span><span class="p">]</span> <span class="o">=</span> <span class="n">kchainbasis</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">kdx</span><span class="p">)</span>
        <span class="n">bd</span><span class="p">[</span><span class="n">kdx</span><span class="p">]</span> <span class="o">=</span> <span class="n">bkMatrix</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="n">kdx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="n">kdx</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">C</span><span class="p">,</span> <span class="n">bd</span></div>


<div class="viewcode-block" id="betti"><a class="viewcode-back" href="../../../algorithms/algorithms.html#algorithms.betti">[docs]</a><span class="k">def</span> <span class="nf">betti</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate the kth-betti numbers for a chain complex with boundary</span>
<span class="sd">    matrices given by bd</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bd: dict of k-boundary matrices keyed on dimension of domain</span>
<span class="sd">    k : int, list or tuple, optional, default=None</span>
<span class="sd">        list must be min value and max value of k values inclusive</span>
<span class="sd">        if None, then all betti numbers for dimensions of existing cells will be</span>
<span class="sd">        computed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    betti : dict</span>
<span class="sd">        Description</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k</span><span class="p">:</span>
        <span class="n">max_dim</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">bd</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">krange</span> <span class="o">=</span> <span class="n">_get_krange</span><span class="p">(</span><span class="n">max_dim</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">krange</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">kvals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">krange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">krange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">bd</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kvals</span> <span class="o">=</span> <span class="n">bd</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">kdx</span> <span class="ow">in</span> <span class="n">kvals</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">hnx</span><span class="o">.</span><span class="n">reduced_row_echelon_form_mod2</span><span class="p">(</span><span class="n">bd</span><span class="p">[</span><span class="n">kdx</span><span class="p">])</span>
        <span class="n">rank</span><span class="p">[</span><span class="n">kdx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">))</span>

    <span class="n">betti</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">kdx</span> <span class="ow">in</span> <span class="n">kvals</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">kdx</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">kvals</span><span class="p">:</span>
            <span class="n">betti</span><span class="p">[</span><span class="n">kdx</span><span class="p">]</span> <span class="o">=</span> <span class="n">bd</span><span class="p">[</span><span class="n">kdx</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">rank</span><span class="p">[</span><span class="n">kdx</span><span class="p">]</span> <span class="o">-</span> <span class="n">rank</span><span class="p">[</span><span class="n">kdx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">continue</span>

    <span class="k">return</span> <span class="n">betti</span></div>


<div class="viewcode-block" id="betti_numbers"><a class="viewcode-back" href="../../../algorithms/algorithms.html#algorithms.betti_numbers">[docs]</a><span class="k">def</span> <span class="nf">betti_numbers</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the kth betti numbers for the simplicial homology of the ASC</span>
<span class="sd">    associated to h</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h : hnx.Hypergraph</span>
<span class="sd">        Hypergraph to compute the betti numbers from</span>
<span class="sd">    k : int or list, optional, default=None</span>
<span class="sd">        list must be min value and max value of k values inclusive</span>
<span class="sd">        if None, then all betti numbers for dimensions of existing cells will be</span>
<span class="sd">        computed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    betti : dict</span>
<span class="sd">        A dictionary of betti numbers keyed by dimension</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">bd</span> <span class="o">=</span> <span class="n">chain_complex</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">betti</span><span class="p">(</span><span class="n">bd</span><span class="p">)</span></div>


<div class="viewcode-block" id="homology_basis"><a class="viewcode-back" href="../../../algorithms/algorithms.html#algorithms.homology_basis">[docs]</a><span class="k">def</span> <span class="nf">homology_basis</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute a basis for the kth-simplicial homology group, $H_k$, defined by a</span>
<span class="sd">    chain complex $C$ with boundary maps given by bd $= \{k:\partial_k \}$</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bd : dict</span>
<span class="sd">        dict of boundary matrices on k-chains to k-1 chains keyed on k</span>
<span class="sd">        if krange is a tuple then all boundary matrices k \in [krange[0],..,krange[1]]</span>
<span class="sd">        inclusive must be in the dictionary</span>
<span class="sd">    k : int or list of ints, optional, default=None</span>
<span class="sd">        k must be a positive integer or a list of</span>
<span class="sd">        2 integers indicating min and max dimensions to be</span>
<span class="sd">        computed, if none given all homology groups will be computed from</span>
<span class="sd">        available boundary matrices in bd</span>
<span class="sd">    boundary : bool</span>
<span class="sd">        option to return a basis for the boundary group from each dimension.</span>
<span class="sd">        Needed to compute the shortest generators in the homology group.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    basis : dict</span>
<span class="sd">        dict of generators as 0-1 tuples keyed by dim</span>
<span class="sd">        basis for dimension k will be returned only if bd[k] and bd[k+1] have</span>
<span class="sd">        been provided.</span>
<span class="sd">    im : dict</span>
<span class="sd">        dict of boundary group generators keyed by dim</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">max_dim</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">bd</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">k</span><span class="p">:</span>
        <span class="n">krange</span> <span class="o">=</span> <span class="n">_get_krange</span><span class="p">(</span><span class="n">max_dim</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">kvals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">bd</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">krange</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">krange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
        <span class="p">)</span>  <span class="c1"># to get kth dim need k+1 bdry matrix</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kvals</span> <span class="o">=</span> <span class="n">bd</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="n">L</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Linv</span> <span class="o">=</span> <span class="n">_compute_matrices_for_snf</span><span class="p">(</span>
        <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">bd</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kvals</span><span class="p">}</span>
    <span class="p">)</span>

    <span class="n">rank</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">kdx</span> <span class="ow">in</span> <span class="n">kvals</span><span class="p">:</span>
        <span class="n">rank</span><span class="p">[</span><span class="n">kdx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">kdx</span><span class="p">])</span>

    <span class="n">basis</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">im</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">kdx</span> <span class="ow">in</span> <span class="n">kvals</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">kdx</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kvals</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">rank1</span> <span class="o">=</span> <span class="n">rank</span><span class="p">[</span><span class="n">kdx</span><span class="p">]</span>
        <span class="n">rank2</span> <span class="o">=</span> <span class="n">rank</span><span class="p">[</span><span class="n">kdx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">ker1</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="n">kdx</span><span class="p">][:,</span> <span class="n">rank1</span><span class="p">:]</span>
        <span class="n">im2</span> <span class="o">=</span> <span class="n">Linv</span><span class="p">[</span><span class="n">kdx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][:,</span> <span class="p">:</span><span class="n">rank2</span><span class="p">]</span>
        <span class="n">cokernel2</span> <span class="o">=</span> <span class="n">Linv</span><span class="p">[</span><span class="n">kdx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][:,</span> <span class="n">rank2</span><span class="p">:]</span>
        <span class="n">cokproj2</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">kdx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">rank2</span><span class="p">:,</span> <span class="p">:]</span>

        <span class="n">proj</span> <span class="o">=</span> <span class="n">matmulreduce</span><span class="p">([</span><span class="n">cokernel2</span><span class="p">,</span> <span class="n">cokproj2</span><span class="p">,</span> <span class="n">ker1</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">proj</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">reduced_row_echelon_form_mod2</span><span class="p">(</span><span class="n">proj</span><span class="p">)</span>
        <span class="c1"># proj = np.array(proj)</span>
        <span class="n">basis</span><span class="p">[</span><span class="n">kdx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">row</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">proj</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">row</span><span class="p">)])</span>
        <span class="k">if</span> <span class="n">boundary</span><span class="p">:</span>
            <span class="n">im</span><span class="p">[</span><span class="n">kdx</span><span class="p">]</span> <span class="o">=</span> <span class="n">im2</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">boundary</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">basis</span><span class="p">,</span> <span class="n">im</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">basis</span></div>


<div class="viewcode-block" id="hypergraph_homology_basis"><a class="viewcode-back" href="../../../algorithms/algorithms.html#algorithms.hypergraph_homology_basis">[docs]</a><span class="k">def</span> <span class="nf">hypergraph_homology_basis</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">shortest</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">interpreted</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the kth-homology groups mod 2 for the ASC</span>
<span class="sd">    associated with the hypergraph h for k in krange inclusive</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    h : hnx.Hypergraph</span>
<span class="sd">    k : int or list of length 2, optional, default = None</span>
<span class="sd">        k must be an integer greater than 0 or a list of</span>
<span class="sd">        length 2 indicating min and max dimensions to be</span>
<span class="sd">        computed</span>
<span class="sd">    shortest : bool, optional, default=False</span>
<span class="sd">        option to look for shortest representative for each coset in the</span>
<span class="sd">        homology group, only good for relatively small examples</span>
<span class="sd">    interpreted : bool, optional, default = True</span>
<span class="sd">        if True will return an explicit basis in terms of the k-chains</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    basis : list</span>
<span class="sd">        list of generators as k-chains as boolean vectors</span>
<span class="sd">    interpreted_basis :</span>
<span class="sd">        lists of kchains in basis</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">C</span><span class="p">,</span> <span class="n">bd</span> <span class="o">=</span> <span class="n">chain_complex</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shortest</span><span class="p">:</span>
        <span class="n">basis</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">tbasis</span><span class="p">,</span> <span class="n">im</span> <span class="o">=</span> <span class="n">homology_basis</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">kdx</span> <span class="ow">in</span> <span class="n">tbasis</span><span class="p">:</span>
            <span class="n">imgrp</span> <span class="o">=</span> <span class="n">boundary_group</span><span class="p">(</span><span class="n">im</span><span class="p">[</span><span class="n">kdx</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">imgrp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">basis</span><span class="p">[</span><span class="n">kdx</span><span class="p">]</span> <span class="o">=</span> <span class="n">tbasis</span><span class="p">[</span><span class="n">kdx</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">tbasis</span><span class="p">[</span><span class="n">kdx</span><span class="p">]:</span>
                    <span class="n">coset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">imgrp</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="p">)</span>  <span class="c1"># dimensions appear to be wrong. See tests2 cell 5</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">coset</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">basis</span><span class="p">[</span><span class="n">kdx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coset</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="n">basis</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">basis</span> <span class="o">=</span> <span class="n">homology_basis</span><span class="p">(</span><span class="n">bd</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">interpreted</span><span class="p">:</span>
        <span class="n">interpreted_basis</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">kdx</span> <span class="ow">in</span> <span class="n">basis</span><span class="p">:</span>
            <span class="n">interpreted_basis</span><span class="p">[</span><span class="n">kdx</span><span class="p">]</span> <span class="o">=</span> <span class="n">interpret</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="n">kdx</span><span class="p">],</span> <span class="n">basis</span><span class="p">[</span><span class="n">kdx</span><span class="p">],</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">basis</span><span class="p">,</span> <span class="n">interpreted_basis</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">basis</span></div>


<div class="viewcode-block" id="interpret"><a class="viewcode-back" href="../../../algorithms/algorithms.html#algorithms.interpret">[docs]</a><span class="k">def</span> <span class="nf">interpret</span><span class="p">(</span><span class="n">Ck</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the data as represented in Ck associated with the arr</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Ck : list</span>
<span class="sd">        a list of k-cells being referenced by arr</span>
<span class="sd">    arr : np.array</span>
<span class="sd">        array of 0-1 vectors</span>
<span class="sd">    labels : dict, optional</span>
<span class="sd">        dictionary of labels to associate to the nodes in the cells</span>

<span class="sd">    Returns</span>
<span class="sd">    ----</span>
<span class="sd">    : list</span>
<span class="sd">        list of k-cells referenced by data in Ck</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">labels</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cell</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">cell</span><span class="p">:</span>
                <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>

    <span class="n">output</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ck</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vec</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">HyperNetXError</span><span class="p">(</span><span class="s2">&quot;elements of arr must have the same length as Ck&quot;</span><span class="p">)</span>
        <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">translate</span><span class="p">(</span><span class="n">Ck</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vec</span><span class="p">))</span> <span class="k">if</span> <span class="n">vec</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">output</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023 Battelle Memorial Institute.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>