<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>hypernetx.classes.hypergraph &mdash; HyperNetX 2.0.5 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
        <script src="../../../_static/clipboard.min.js"></script>
        <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            HyperNetX
              <img src="../../../_static/hnx_logo_smaller.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../overview/index.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installing HyperNetX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../core.html">HyperNetX Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../hypergraph101.html">A Gentle Introduction to Hypergraph Mathematics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../hypconstructors.html">Hypergraph Constructors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../widget.html">Visualization Widget</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modularity.html">Algorithms: Modularity and Clustering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../publications.html">Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">HyperNetX</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">hypernetx.classes.hypergraph</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for hypernetx.classes.hypergraph</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright Â© 2018 Battelle Memorial Institute</span>
<span class="c1"># All rights reserved.</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">warnings</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Hashable</span>

<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">networkx.algorithms</span> <span class="kn">import</span> <span class="n">bipartite</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">coo_matrix</span><span class="p">,</span> <span class="n">csr_matrix</span>

<span class="kn">from</span> <span class="nn">hypernetx.classes</span> <span class="kn">import</span> <span class="n">Entity</span><span class="p">,</span> <span class="n">EntitySet</span>
<span class="kn">from</span> <span class="nn">hypernetx.exception</span> <span class="kn">import</span> <span class="n">HyperNetXError</span>
<span class="kn">from</span> <span class="nn">hypernetx.utils.decorators</span> <span class="kn">import</span> <span class="n">warn_nwhy</span>
<span class="kn">from</span> <span class="nn">hypernetx.classes.helpers</span> <span class="kn">import</span> <span class="n">merge_nested_dicts</span><span class="p">,</span> <span class="n">dict_depth</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Hypergraph&quot;</span><span class="p">]</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span>


<div class="viewcode-block" id="Hypergraph"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph">[docs]</a><span class="k">class</span> <span class="nc">Hypergraph</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    setsystem : (optional) dict of iterables, dict of dicts,iterable of iterables,</span>
<span class="sd">        pandas.DataFrame, numpy.ndarray, default = None</span>
<span class="sd">        See SetSystem above for additional setsystem requirements.</span>

<span class="sd">    edge_col : (optional) str | int, default = 0</span>
<span class="sd">        column index (or name) in pandas.dataframe or numpy.ndarray,</span>
<span class="sd">        used for (hyper)edge ids. Will be used to reference edgeids for</span>
<span class="sd">        all set systems.</span>

<span class="sd">    node_col : (optional) str | int, default = 1</span>
<span class="sd">        column index (or name) in pandas.dataframe or numpy.ndarray,</span>
<span class="sd">        used for node ids. Will be used to reference nodeids for all set systems.</span>

<span class="sd">    cell_weight_col : (optional) str | int, default = None</span>
<span class="sd">        column index (or name) in pandas.dataframe or numpy.ndarray used for</span>
<span class="sd">        referencing cell weights. For a dict of dicts references key in cell</span>
<span class="sd">        property dicts.</span>

<span class="sd">    cell_weights : (optional) Sequence[float,int] | int |  float , default = 1.0</span>
<span class="sd">        User specified cell_weights or default cell weight.</span>
<span class="sd">        Sequential values are only used if setsystem is a</span>
<span class="sd">        dataframe or ndarray in which case the sequence must</span>
<span class="sd">        have the same length and order as these objects.</span>
<span class="sd">        Sequential values are ignored for dataframes if cell_weight_col is already</span>
<span class="sd">        a column in the data frame.</span>
<span class="sd">        If cell_weights is assigned a single value</span>
<span class="sd">        then it will be used as default for missing values or when no cell_weight_col</span>
<span class="sd">        is given.</span>

<span class="sd">    cell_properties : (optional) Sequence[int | str] | Mapping[T,Mapping[T,Mapping[str,Any]]],</span>
<span class="sd">        default = None</span>
<span class="sd">        Column names from pd.DataFrame to use as cell properties</span>
<span class="sd">        or a dict assigning cell_property to incidence pairs of edges and</span>
<span class="sd">        nodes. Will generate a misc_cell_properties, which may have variable lengths per cell.</span>

<span class="sd">    misc_cell_properties : (optional) str | int, default = None</span>
<span class="sd">        Column name of dataframe corresponding to a column of variable</span>
<span class="sd">        length property dictionaries for the cell. Ignored for other setsystem</span>
<span class="sd">        types.</span>

<span class="sd">    aggregateby : (optional) str, dict, default = &#39;first&#39;</span>
<span class="sd">        By default duplicate edge,node incidences will be dropped unless</span>
<span class="sd">        specified with `aggregateby`.</span>
<span class="sd">        See pandas.DataFrame.agg() methods for additional syntax and usage</span>
<span class="sd">        information.</span>

<span class="sd">    edge_properties : (optional) pd.DataFrame | dict, default = None</span>
<span class="sd">        Properties associated with edge ids.</span>
<span class="sd">        First column of dataframe or keys of dict link to edge ids in</span>
<span class="sd">        setsystem.</span>

<span class="sd">    node_properties : (optional) pd.DataFrame | dict, default = None</span>
<span class="sd">        Properties associated with node ids.</span>
<span class="sd">        First column of dataframe or keys of dict link to node ids in</span>
<span class="sd">        setsystem.</span>

<span class="sd">    properties : (optional) pd.DataFrame | dict, default = None</span>
<span class="sd">        Concatenation/union of edge_properties and node_properties.</span>
<span class="sd">        By default, the object id is used and should be the first column of</span>
<span class="sd">        the dataframe, or key in the dict. If there are nodes and edges</span>
<span class="sd">        with the same ids and different properties then use the edge_properties</span>
<span class="sd">        and node_properties keywords.</span>

<span class="sd">    misc_properties : (optional) int | str, default = None</span>
<span class="sd">        Column of property dataframes with dtype=dict. Intended for variable</span>
<span class="sd">        length property dictionaries for the objects.</span>

<span class="sd">    edge_weight_prop : (optional) str, default = None,</span>
<span class="sd">        Name of property in edge_properties to use for weight.</span>

<span class="sd">    node_weight_prop : (optional) str, default = None,</span>
<span class="sd">        Name of property in node_properties to use for weight.</span>

<span class="sd">    weight_prop : (optional) str, default = None</span>
<span class="sd">        Name of property in properties to use for &#39;weight&#39;</span>

<span class="sd">    default_edge_weight : (optional) int | float, default = 1</span>
<span class="sd">        Used when edge weight property is missing or undefined.</span>

<span class="sd">    default_node_weight : (optional) int | float, default = 1</span>
<span class="sd">        Used when node weight property is missing or undefined</span>

<span class="sd">    name : (optional) str, default = None</span>
<span class="sd">        Name assigned to hypergraph</span>


<span class="sd">    ======================</span>
<span class="sd">    Hypergraphs in HNX 2.0</span>
<span class="sd">    ======================</span>

<span class="sd">    An hnx.Hypergraph H = (V,E) references a pair of disjoint sets:</span>
<span class="sd">    V = nodes (vertices) and E = (hyper)edges.</span>

<span class="sd">    HNX allows for multi-edges by distinguishing edges by</span>
<span class="sd">    their identifiers instead of their contents. For example, if</span>
<span class="sd">    V = {1,2,3} and E = {e1,e2,e3},</span>
<span class="sd">    where e1 = {1,2}, e2 = {1,2}, and e3 = {1,2,3},</span>
<span class="sd">    the edges e1 and e2 contain the same set of nodes and yet</span>
<span class="sd">    are distinct and are distinguishable within H = (V,E).</span>

<span class="sd">    New as of version 2.0, HNX provides methods to easily store and</span>
<span class="sd">    access additional metadata such as cell, edge, and node weights.</span>
<span class="sd">    Metadata associated with (edge,node) incidences</span>
<span class="sd">    are referenced as **cell_properties**.</span>
<span class="sd">    Metadata associated with a single edge or node is referenced</span>
<span class="sd">    as its **properties**.</span>

<span class="sd">    The fundamental object needed to create a hypergraph is a **setsystem**. The</span>
<span class="sd">    setsystem defines the many-to-many relationships between edges and nodes in</span>
<span class="sd">    the hypergraph. Cell properties for the incidence pairs can be defined within</span>
<span class="sd">    the setsystem or in a separate pandas.Dataframe or dict.</span>
<span class="sd">    Edge and node properties are defined with a pandas.DataFrame or dict.</span>

<span class="sd">    SetSystems</span>
<span class="sd">    ----------</span>
<span class="sd">    There are five types of setsystems currently accepted by the library.</span>

<span class="sd">    1.  **iterable of iterables** : Barebones hypergraph uses Pandas default</span>
<span class="sd">        indexing to generate hyperedge ids. Elements must be hashable.: ::</span>

<span class="sd">        &gt;&gt;&gt; H = Hypergraph([{1,2},{1,2},{1,2,3}])</span>

<span class="sd">    2.  **dictionary of iterables** : the most basic way to express many-to-many</span>
<span class="sd">        relationships providing edge ids. The elements of the iterables must be</span>
<span class="sd">        hashable): ::</span>

<span class="sd">        &gt;&gt;&gt; H = Hypergraph({&#39;e1&#39;:[1,2],&#39;e2&#39;:[1,2],&#39;e3&#39;:[1,2,3]})</span>

<span class="sd">    3.  **dictionary of dictionaries**  : allows cell properties to be assigned</span>
<span class="sd">        to a specific (edge, node) incidence. This is particularly useful when</span>
<span class="sd">        there are variable length dictionaries assigned to each pair: ::</span>

<span class="sd">        &gt;&gt;&gt; d = {&#39;e1&#39;:{ 1: {&#39;w&#39;:0.5, &#39;name&#39;: &#39;related_to&#39;},</span>
<span class="sd">        &gt;&gt;&gt;             2: {&#39;w&#39;:0.1, &#39;name&#39;: &#39;related_to&#39;,</span>
<span class="sd">        &gt;&gt;&gt;                 &#39;startdate&#39;: &#39;05.13.2020&#39;}},</span>
<span class="sd">        &gt;&gt;&gt;      &#39;e2&#39;:{ 1: {&#39;w&#39;:0.52, &#39;name&#39;: &#39;owned_by&#39;},</span>
<span class="sd">        &gt;&gt;&gt;             2: {&#39;w&#39;:0.2}},</span>
<span class="sd">        &gt;&gt;&gt;      &#39;e3&#39;:{ 1: {&#39;w&#39;:0.5, &#39;name&#39;: &#39;related_to&#39;},</span>
<span class="sd">        &gt;&gt;&gt;             2: {&#39;w&#39;:0.2, &#39;name&#39;: &#39;owner_of&#39;},</span>
<span class="sd">        &gt;&gt;&gt;             3: {&#39;w&#39;:1, &#39;type&#39;: &#39;relationship&#39;}}</span>

<span class="sd">        &gt;&gt;&gt; H = Hypergraph(d, cell_weight_col=&#39;w&#39;)</span>

<span class="sd">    4.  **pandas.DataFrame** For large datasets and for datasets with cell</span>
<span class="sd">        properties it is most efficient to construct a hypergraph directly from</span>
<span class="sd">        a pandas.DataFrame. Incidence pairs are in the first two columns.</span>
<span class="sd">        Cell properties shared by all incidence pairs can be placed in their own</span>
<span class="sd">        column of the dataframe. Variable length dictionaries of cell properties</span>
<span class="sd">        particular to only some of the incidence pairs may be placed in a single</span>
<span class="sd">        column of the dataframe. Representing the data above as a dataframe df:</span>

<span class="sd">        +-----------+-----------+-----------+-----------------------------------+</span>
<span class="sd">        |   col1    |   col2    |   w       |  col3                             |</span>
<span class="sd">        +-----------+-----------+-----------+-----------------------------------+</span>
<span class="sd">        |   e1      |   1       |   0.5     | {&#39;name&#39;:&#39;related_to&#39;}             |</span>
<span class="sd">        +-----------+-----------+-----------+-----------------------------------+</span>
<span class="sd">        |   e1      |   2       |   0.1     | {&quot;name&quot;:&quot;related_to&quot;,             |</span>
<span class="sd">        |           |           |           |  &quot;startdate&quot;:&quot;05.13.2020&quot;}        |</span>
<span class="sd">        +-----------+-----------+-----------+-----------------------------------+</span>
<span class="sd">        |   e2      |   1       |   0.52    | {&quot;name&quot;:&quot;owned_by&quot;}               |</span>
<span class="sd">        +-----------+-----------+-----------+-----------------------------------+</span>
<span class="sd">        |   e2      |   2       |   0.2     |                                   |</span>
<span class="sd">        +-----------+-----------+-----------+-----------------------------------+</span>
<span class="sd">        |   ...     |   ...     |   ...     | {...}                             |</span>
<span class="sd">        +-----------+-----------+-----------+-----------------------------------+</span>

<span class="sd">        The first row of the dataframe is used to reference each column. ::</span>

<span class="sd">        &gt;&gt;&gt; H = Hypergraph(df,edge_col=&quot;col1&quot;,node_col=&quot;col2&quot;,</span>
<span class="sd">        &gt;&gt;&gt;                 cell_weight_col=&quot;w&quot;,misc_cell_properties=&quot;col3&quot;)</span>

<span class="sd">    5.  **numpy.ndarray** For homogeneous datasets given in an ndarray a</span>
<span class="sd">        pandas dataframe is generated and column names are added from the</span>
<span class="sd">        edge_col and node_col arguments. Cell properties containing multiple data</span>
<span class="sd">        types are added with a separate dataframe or dict and passed through the</span>
<span class="sd">        cell_properties keyword. ::</span>

<span class="sd">        &gt;&gt;&gt; arr = np.array([[&#39;e1&#39;,&#39;1&#39;],[&#39;e1&#39;,&#39;2&#39;],</span>
<span class="sd">        &gt;&gt;&gt;                 [&#39;e2&#39;,&#39;1&#39;],[&#39;e2&#39;,&#39;2&#39;],</span>
<span class="sd">        &gt;&gt;&gt;                 [&#39;e3&#39;,&#39;1&#39;],[&#39;e3&#39;,&#39;2&#39;],[&#39;e3&#39;,&#39;3&#39;]])</span>
<span class="sd">        &gt;&gt;&gt; H = hnx.Hypergraph(arr, column_names=[&#39;col1&#39;,&#39;col2&#39;])</span>


<span class="sd">    Edge and Node Properties</span>
<span class="sd">    ------------------------</span>
<span class="sd">    Properties specific to a single edge or node are passed through the</span>
<span class="sd">    keywords: **edge_properties, node_properties, properties**.</span>
<span class="sd">    Properties may be passed as dataframes or dicts.</span>
<span class="sd">    The first column or index of the dataframe or keys of the dict keys</span>
<span class="sd">    correspond to the edge and/or node identifiers.</span>
<span class="sd">    If identifiers are shared among edges and nodes, or are distinct</span>
<span class="sd">    for edges and nodes, properties may be combined into a single</span>
<span class="sd">    object and passed to the **properties** keyword. For example:</span>

<span class="sd">    +-----------+-----------+---------------------------------------+</span>
<span class="sd">    |   id      |   weight  |   properties                          |</span>
<span class="sd">    +-----------+-----------+---------------------------------------+</span>
<span class="sd">    |   e1      |   5.0     |   {&#39;type&#39;:&#39;event&#39;}                    |</span>
<span class="sd">    +-----------+-----------+---------------------------------------+</span>
<span class="sd">    |   e2      |   0.52    |   {&quot;name&quot;:&quot;owned_by&quot;}                 |</span>
<span class="sd">    +-----------+-----------+---------------------------------------+</span>
<span class="sd">    |   ...     |   ...     |   {...}                               |</span>
<span class="sd">    +-----------+-----------+---------------------------------------+</span>
<span class="sd">    |   1       |   1.2     |   {&#39;color&#39;:&#39;red&#39;}                     |</span>
<span class="sd">    +-----------+-----------+---------------------------------------+</span>
<span class="sd">    |   2       |   .003    |   {&#39;name&#39;:&#39;Fido&#39;,&#39;color&#39;:&#39;brown&#39;}     |</span>
<span class="sd">    +-----------+-----------+---------------------------------------+</span>
<span class="sd">    |   3       |   1.0     |    {}                                 |</span>
<span class="sd">    +-----------+-----------+---------------------------------------+</span>

<span class="sd">    A properties dictionary should have the format: ::</span>

<span class="sd">        dp = {id1 : {prop1:val1, prop2,val2,...}, id2 : ... }</span>

<span class="sd">    A properties dataframe may be used for nodes and edges sharing ids</span>
<span class="sd">    but differing in cell properties by adding a level index using 0</span>
<span class="sd">    for edges and 1 for nodes:</span>

<span class="sd">    +-----------+-----------+-----------+---------------------------+</span>
<span class="sd">    |  level    |   id      |   weight  |       properties          |</span>
<span class="sd">    +-----------+-----------+-----------+---------------------------+</span>
<span class="sd">    |   0       |   e1      |   5.0     |   {&#39;type&#39;:&#39;event&#39;}        |</span>
<span class="sd">    +-----------+-----------+-----------+---------------------------+</span>
<span class="sd">    |   0       |   e2      |    0.52   |   {&quot;name&quot;:&quot;owned_by&quot;}     |</span>
<span class="sd">    +-----------+-----------+-----------+---------------------------+</span>
<span class="sd">    |   ...     |   ...     |    ...    |          {...}            |</span>
<span class="sd">    +-----------+-----------+-----------+---------------------------+</span>
<span class="sd">    |   1       |   1.2     |   {&#39;color&#39;:&#39;red&#39;}                     |</span>
<span class="sd">    +-----------+-----------+-----------+---------------------------+</span>
<span class="sd">    |   2       |   .003    |   {&#39;name&#39;:&#39;Fido&#39;,&#39;color&#39;:&#39;brown&#39;}     |</span>
<span class="sd">    +-----------+-----------+-----------+---------------------------+</span>
<span class="sd">    |   ...     |   ...     |    ...    |          {...}            |</span>
<span class="sd">    +-----------+-----------+-----------+---------------------------+</span>



<span class="sd">    Weights</span>
<span class="sd">    -------</span>
<span class="sd">    The default key for cell and object weights is &quot;weight&quot;. The default value</span>
<span class="sd">    is 1. Weights may be assigned and/or a new default prescribed in the</span>
<span class="sd">    constructor using **cell_weight_col** and **cell_weights** for incidence pairs,</span>
<span class="sd">    and using **edge_weight_prop, node_weight_prop, weight_prop,</span>
<span class="sd">    default_edge_weight,** and **default_node_weight** for node and edge weights.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@warn_nwhy</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">setsystem</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span>
            <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
            <span class="o">|</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">T</span><span class="p">]]</span>
            <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">T</span><span class="p">]]</span>
            <span class="o">|</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">edge_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">node_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">cell_weight_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;cell_weights&quot;</span><span class="p">,</span>
        <span class="n">cell_weights</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">cell_properties</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">misc_cell_properties_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">aggregateby</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;first&quot;</span><span class="p">,</span>
        <span class="n">edge_properties</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">node_properties</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">properties</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">misc_properties_col</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">edge_weight_prop_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="s2">&quot;weight&quot;</span><span class="p">,</span>
        <span class="n">node_weight_prop_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="s2">&quot;weight&quot;</span><span class="p">,</span>
        <span class="n">weight_prop_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="s2">&quot;weight&quot;</span><span class="p">,</span>
        <span class="n">default_edge_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">default_node_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">default_weight</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">misc_cell_properties_col</span> <span class="o">=</span> <span class="n">misc_cell_properties</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">misc_cell_properties_col</span> <span class="ow">or</span> <span class="s2">&quot;cell_properties&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">misc_properties_col</span> <span class="o">=</span> <span class="n">misc_properties_col</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">misc_properties_col</span> <span class="ow">or</span> <span class="s2">&quot;properties&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_edge_weight</span> <span class="o">=</span> <span class="n">default_edge_weight</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">default_edge_weight</span> <span class="ow">or</span> <span class="n">default_weight</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_node_weight</span> <span class="o">=</span> <span class="n">default_node_weight</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">default_node_weight</span> <span class="ow">or</span> <span class="n">default_weight</span>
        <span class="p">)</span>
        <span class="c1">### cell properties</span>

        <span class="k">if</span> <span class="n">setsystem</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1">#### Empty Case</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span> <span class="o">=</span> <span class="n">EntitySet</span><span class="p">({})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="n">EntitySet</span><span class="p">({})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1">#### DataFrame case</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">setsystem</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge_col</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_edge_col</span> <span class="o">=</span> <span class="n">edge_col</span> <span class="o">=</span> <span class="n">setsystem</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">edge_col</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">edge_col</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                        <span class="n">setsystem</span> <span class="o">=</span> <span class="n">setsystem</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">edge_col</span><span class="p">:</span> <span class="s2">&quot;edges&quot;</span><span class="p">})</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_edge_col</span> <span class="o">=</span> <span class="n">edge_col</span> <span class="o">=</span> <span class="s2">&quot;edges&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_edge_col</span> <span class="o">=</span> <span class="n">edge_col</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node_col</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_node_col</span> <span class="o">=</span> <span class="n">node_col</span> <span class="o">=</span> <span class="n">setsystem</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">node_col</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node_col</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                        <span class="n">setsystem</span> <span class="o">=</span> <span class="n">setsystem</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">node_col</span><span class="p">:</span> <span class="s2">&quot;nodes&quot;</span><span class="p">})</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_node_col</span> <span class="o">=</span> <span class="n">node_col</span> <span class="o">=</span> <span class="s2">&quot;nodes&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_node_col</span> <span class="o">=</span> <span class="n">node_col</span>

                <span class="n">entity</span> <span class="o">=</span> <span class="n">setsystem</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell_weight_col</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cell_weight_col</span> <span class="o">=</span> <span class="n">setsystem</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">cell_weight_col</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cell_weight_col</span> <span class="o">=</span> <span class="n">cell_weight_col</span>

                <span class="k">if</span> <span class="n">cell_weight_col</span> <span class="ow">in</span> <span class="n">entity</span><span class="p">:</span>
                    <span class="n">entity</span> <span class="o">=</span> <span class="n">entity</span><span class="o">.</span><span class="n">fillna</span><span class="p">({</span><span class="n">cell_weight_col</span><span class="p">:</span> <span class="n">cell_weights</span><span class="p">})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">entity</span><span class="p">[</span><span class="n">cell_weight_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_weights</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell_properties</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
                    <span class="n">cell_properties</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">c</span>
                        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cell_properties</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">[</span><span class="n">edge_col</span><span class="p">,</span> <span class="n">node_col</span><span class="p">,</span> <span class="n">cell_weight_col</span><span class="p">]</span>
                    <span class="p">]</span>
                    <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge_col</span><span class="p">,</span> <span class="n">node_col</span><span class="p">,</span> <span class="n">cell_weight_col</span><span class="p">]</span> <span class="o">+</span> <span class="n">cell_properties</span>
                    <span class="n">entity</span> <span class="o">=</span> <span class="n">entity</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell_properties</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">cp</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">entity</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                        <span class="n">edge</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="n">entity</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">idx</span><span class="p">][[</span><span class="n">edge_col</span><span class="p">,</span> <span class="n">node_col</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
                        <span class="n">cp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell_properties</span><span class="p">[</span><span class="n">edge</span><span class="p">][</span><span class="n">node</span><span class="p">])</span>
                    <span class="n">entity</span><span class="p">[</span><span class="s2">&quot;cell_properties&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span>

            <span class="k">else</span><span class="p">:</span>  <span class="c1">### Cases Other than DataFrame</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_edge_col</span> <span class="o">=</span> <span class="n">edge_col</span> <span class="o">=</span> <span class="n">edge_col</span> <span class="ow">or</span> <span class="s2">&quot;edges&quot;</span>
                <span class="k">if</span> <span class="n">node_col</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_node_col</span> <span class="o">=</span> <span class="n">node_col</span> <span class="o">=</span> <span class="s2">&quot;nodes&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_node_col</span> <span class="o">=</span> <span class="n">node_col</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cell_weight_col</span> <span class="o">=</span> <span class="n">cell_weight_col</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">setsystem</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">setsystem</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">HyperNetXError</span><span class="p">(</span><span class="s2">&quot;Numpy array must have exactly 2 columns.&quot;</span><span class="p">)</span>
                    <span class="n">entity</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">setsystem</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">edge_col</span><span class="p">,</span> <span class="n">node_col</span><span class="p">])</span>
                    <span class="n">entity</span><span class="p">[</span><span class="n">cell_weight_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_weights</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">setsystem</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="c1">## check if it is a dict of iterables or a nested dict. if the latter then pull</span>
                    <span class="c1">## out the nested dicts as cell properties.</span>
                    <span class="c1">## cell properties must be of the same type as setsystem</span>

                    <span class="n">entity</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">setsystem</span><span class="p">)</span><span class="o">.</span><span class="n">explode</span><span class="p">()</span>
                    <span class="n">entity</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">edge_col</span><span class="p">:</span> <span class="n">entity</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_list</span><span class="p">(),</span> <span class="n">node_col</span><span class="p">:</span> <span class="n">entity</span><span class="o">.</span><span class="n">values</span><span class="p">}</span>
                    <span class="p">)</span>

                    <span class="k">if</span> <span class="n">dict_depth</span><span class="p">(</span><span class="n">setsystem</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">cell_props</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">setsystem</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cell_properties</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                            <span class="c1">## if setsystem is a dict then cell properties must be a dict</span>
                            <span class="n">cell_properties</span> <span class="o">=</span> <span class="n">merge_nested_dicts</span><span class="p">(</span>
                                <span class="n">cell_props</span><span class="p">,</span> <span class="n">cell_properties</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">cell_properties</span> <span class="o">=</span> <span class="n">cell_props</span>

                        <span class="n">df</span> <span class="o">=</span> <span class="n">setsystem</span>
                        <span class="n">cp</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">wt</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">entity</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                            <span class="n">edge</span><span class="p">,</span> <span class="n">node</span> <span class="o">=</span> <span class="n">entity</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">idx</span><span class="p">][[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
                            <span class="n">wt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">edge</span><span class="p">][</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cell_weight_col</span><span class="p">,</span> <span class="n">cell_weights</span><span class="p">))</span>
                            <span class="n">cp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">edge</span><span class="p">][</span><span class="n">node</span><span class="p">])</span>
                        <span class="n">entity</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_cell_weight_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">wt</span>
                        <span class="n">entity</span><span class="p">[</span><span class="s2">&quot;cell_properties&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">entity</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_cell_weight_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_weights</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">setsystem</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                    <span class="n">entity</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">setsystem</span><span class="p">)</span><span class="o">.</span><span class="n">explode</span><span class="p">()</span>
                    <span class="n">entity</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                        <span class="p">{</span><span class="n">edge_col</span><span class="p">:</span> <span class="n">entity</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_list</span><span class="p">(),</span> <span class="n">node_col</span><span class="p">:</span> <span class="n">entity</span><span class="o">.</span><span class="n">values</span><span class="p">}</span>
                    <span class="p">)</span>
                    <span class="n">entity</span><span class="p">[</span><span class="s2">&quot;cell_weights&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cell_weights</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">HyperNetXError</span><span class="p">(</span>
                        <span class="s2">&quot;setsystem is not supported or is in the wrong format.&quot;</span>
                    <span class="p">)</span>

            <span class="k">def</span> <span class="nf">props2dict</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">df</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">{}</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s2">&quot;index&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">properties</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">edge_properties</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">node_properties</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">edge_properties</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">edge_properties</span> <span class="o">=</span> <span class="n">props2dict</span><span class="p">(</span><span class="n">edge_properties</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">entity</span><span class="p">[</span><span class="n">edge_col</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edge_properties</span><span class="p">:</span>
                                <span class="n">edge_properties</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edge_properties</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                            <span class="n">v</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">edge_weight_prop_col</span><span class="p">,</span> <span class="n">default_edge_weight</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">edge_properties</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">if</span> <span class="n">node_properties</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">node_properties</span> <span class="o">=</span> <span class="n">props2dict</span><span class="p">(</span><span class="n">node_properties</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">entity</span><span class="p">[</span><span class="n">node_col</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">node_properties</span><span class="p">:</span>
                                <span class="n">node_properties</span><span class="p">[</span><span class="n">nd</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">node_properties</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                            <span class="n">v</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">node_weight_prop_col</span><span class="p">,</span> <span class="n">default_node_weight</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">node_properties</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="n">properties</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">edge_properties</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="n">node_properties</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">properties</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">weight_prop_col</span> <span class="ow">in</span> <span class="n">properties</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                        <span class="n">properties</span> <span class="o">=</span> <span class="n">properties</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span>
                            <span class="p">{</span><span class="n">weight_prop_col</span><span class="p">:</span> <span class="n">default_weight</span><span class="p">}</span>
                        <span class="p">)</span>
                    <span class="k">elif</span> <span class="n">misc_properties_col</span> <span class="ow">in</span> <span class="n">properties</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">properties</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                                <span class="n">properties</span><span class="p">[</span><span class="n">misc_properties_col</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span> <span class="nb">dict</span>
                            <span class="p">):</span>
                                <span class="n">properties</span><span class="p">[</span><span class="n">misc_properties_col</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                                    <span class="n">weight_prop_col</span><span class="p">:</span> <span class="n">default_weight</span>
                                <span class="p">}</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">properties</span><span class="p">[</span><span class="n">misc_properties_col</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
                                    <span class="n">weight_prop_col</span><span class="p">,</span> <span class="n">default_weight</span>
                                <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">properties</span><span class="p">[</span><span class="n">weight_prop_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">default_weight</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">properties</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">dict_depth</span><span class="p">(</span><span class="n">properties</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">properties</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
                            <span class="p">[</span>
                                <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">k</span><span class="p">,</span> <span class="n">misc_properties_col</span><span class="p">:</span> <span class="n">v</span><span class="p">}</span>
                                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">properties</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                            <span class="p">]</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">properties</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="n">misc_properties_col</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
                                <span class="n">properties</span><span class="p">[</span><span class="n">misc_properties_col</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
                                    <span class="n">weight_prop_col</span><span class="p">,</span> <span class="n">default_weight</span>
                                <span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">properties</span><span class="p">[</span><span class="n">misc_properties_col</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                                    <span class="n">weight_prop_col</span><span class="p">:</span> <span class="n">default_weight</span>
                                <span class="p">}</span>
                    <span class="k">elif</span> <span class="nb">set</span><span class="p">(</span><span class="n">properties</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">}:</span>
                        <span class="n">edge_properties</span> <span class="o">=</span> <span class="n">properties</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">entity</span><span class="p">[</span><span class="n">edge_col</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edge_properties</span><span class="p">:</span>
                                <span class="n">edge_properties</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                                    <span class="n">edge_weight_prop_col</span><span class="p">:</span> <span class="n">default_edge_weight</span>
                                <span class="p">}</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">edge_properties</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
                                    <span class="n">edge_weight_prop_col</span><span class="p">,</span> <span class="n">default_edge_weight</span>
                                <span class="p">)</span>
                        <span class="n">node_properties</span> <span class="o">=</span> <span class="n">properties</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">entity</span><span class="p">[</span><span class="n">node_col</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">nd</span> <span class="ow">in</span> <span class="n">node_properties</span><span class="p">:</span>
                                <span class="n">node_properties</span><span class="p">[</span><span class="n">nd</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                                    <span class="n">node_weight_prop_col</span><span class="p">:</span> <span class="n">default_node_weight</span>
                                <span class="p">}</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">node_properties</span><span class="p">[</span><span class="n">nd</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
                                    <span class="n">node_weight_prop_col</span><span class="p">,</span> <span class="n">default_node_weight</span>
                                <span class="p">)</span>
                        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">properties</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                                <span class="n">properties</span><span class="p">[</span><span class="n">misc_properties_col</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span> <span class="nb">dict</span>
                            <span class="p">):</span>
                                <span class="n">properties</span><span class="p">[</span><span class="n">misc_properties_col</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                                    <span class="n">weight_prop_col</span><span class="p">:</span> <span class="n">default_weight</span>
                                <span class="p">}</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">properties</span><span class="p">[</span><span class="n">misc_properties_col</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span>
                                    <span class="n">weight_prop_col</span><span class="p">,</span> <span class="n">default_weight</span>
                                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">E</span> <span class="o">=</span> <span class="n">EntitySet</span><span class="p">(</span>
                <span class="n">entity</span><span class="o">=</span><span class="n">entity</span><span class="p">,</span>
                <span class="n">level1</span><span class="o">=</span><span class="n">edge_col</span><span class="p">,</span>
                <span class="n">level2</span><span class="o">=</span><span class="n">node_col</span><span class="p">,</span>
                <span class="n">weight_col</span><span class="o">=</span><span class="n">cell_weight_col</span><span class="p">,</span>
                <span class="n">weights</span><span class="o">=</span><span class="n">cell_weights</span><span class="p">,</span>
                <span class="n">cell_properties</span><span class="o">=</span><span class="n">cell_properties</span><span class="p">,</span>
                <span class="n">misc_cell_props_col</span><span class="o">=</span><span class="n">misc_cell_properties_col</span> <span class="ow">or</span> <span class="s2">&quot;cell_properties&quot;</span><span class="p">,</span>
                <span class="n">aggregateby</span><span class="o">=</span><span class="n">aggregateby</span> <span class="ow">or</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
                <span class="n">properties</span><span class="o">=</span><span class="n">properties</span><span class="p">,</span>
                <span class="n">misc_props_col</span><span class="o">=</span><span class="n">misc_properties_col</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="o">.</span><span class="n">restrict_to_levels</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dataframe</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="o">.</span><span class="n">cell_properties</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_cols</span> <span class="o">=</span> <span class="n">data_cols</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_col</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dataframe</span><span class="p">[</span><span class="n">data_cols</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataframe</span><span class="p">[</span><span class="n">data_cols</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;category&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">locals</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_default_state</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Object associated with self._edges.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        EntitySet</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Object associated with self._nodes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        EntitySet</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dataframe</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns dataframe of incidence pairs and their properties.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dataframe</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns dataframe of edge and node properties.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="o">.</span><span class="n">properties</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">edge_props</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dataframe of edge properties</span>
<span class="sd">        indexed on edge ids</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">node_props</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dataframe of node properties</span>
<span class="sd">        indexed on node ids</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pd.DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">incidence_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dictionary keyed by edge uids with values the uids of nodes in each</span>
<span class="sd">        edge</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="o">.</span><span class="n">incidence_dict</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (number of nodes, number of edges)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="o">.</span><span class="n">elements</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_edges</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation of hypergraph</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, &lt;class &#39;hypernetx.classes.hypergraph.Hypergraph&#39;&gt;&quot;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation of hypergraph</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, hypernetx.classes.hypergraph.Hypergraph&quot;</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of nodes</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nodes</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the nodes of the hypergraph</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict_keyiterator</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns boolean indicating if item is in self.nodes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        item : hashable or Entity</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the neighbors of node</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node : Entity or hashable</span>
<span class="sd">            If hashable, then must be uid of node in hypergraph</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        neighbors(node) : iterator</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

<div class="viewcode-block" id="Hypergraph.get_cell_properties"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.get_cell_properties">[docs]</a>    <span class="k">def</span> <span class="nf">get_cell_properties</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">prop_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get cell properties on a specified edge and node</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge : str</span>
<span class="sd">            edgeid</span>
<span class="sd">        node : str</span>
<span class="sd">            nodeid</span>
<span class="sd">        prop_name : str, optional</span>
<span class="sd">            name of a cell property; if None, all cell properties will be returned</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : int or str or dict of {str: any}</span>
<span class="sd">            cell property value if `prop_name` is provided, otherwise ``dict`` of all</span>
<span class="sd">            cell properties and values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">prop_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">get_cell_properties</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">get_cell_property</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">prop_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.get_properties"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.get_properties">[docs]</a>    <span class="k">def</span> <span class="nf">get_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prop_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns an object&#39;s specific property or all properties</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        id : hashable</span>
<span class="sd">            edge or node id</span>
<span class="sd">        level : int | None , optional, default = None</span>
<span class="sd">            if separate edge and node properties then enter 0 for edges</span>
<span class="sd">            and 1 for nodes.</span>
<span class="sd">        prop_name : str | None, optional, default = None</span>
<span class="sd">            if None then all properties associated with the object will  be</span>
<span class="sd">            returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : str or dict</span>
<span class="sd">            single property or dictionary of properties</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">prop_name</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="o">.</span><span class="n">get_properties</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="o">.</span><span class="n">get_property</span><span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">prop_name</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.get_linegraph"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.get_linegraph">[docs]</a>    <span class="nd">@warn_nwhy</span>
    <span class="k">def</span> <span class="nf">get_linegraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an ::term::s-linegraph for the Hypergraph.</span>
<span class="sd">        If edges=True (default)then the edges will be the vertices of the line</span>
<span class="sd">        graph. Two vertices are connected by an s-line-graph edge if the</span>
<span class="sd">        corresponding hypergraph edges intersect in at least s hypergraph nodes.</span>
<span class="sd">        If edges=False, the hypergraph nodes will be the vertices of the line</span>
<span class="sd">        graph. Two vertices are connected if the nodes they correspond to share</span>
<span class="sd">        at least s incident hyper edges.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        s : int</span>
<span class="sd">            The width of the connections.</span>
<span class="sd">        edges : bool, optional, default = True</span>
<span class="sd">            Determine if edges or nodes will be the vertices in the linegraph.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nx.Graph</span>
<span class="sd">            A NetworkX graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span>
        <span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;sedgelg&quot;</span> <span class="k">if</span> <span class="n">edges</span> <span class="k">else</span> <span class="s2">&quot;snodelg&quot;</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">s</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">Amap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_adjacency_matrix</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">Amaplst</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_props</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Amap</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">Amap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">Amaplst</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_props</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Amap</span><span class="p">]</span>

        <span class="c1">### TODO: add key function to compute weights lambda x,y : funcval</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
        <span class="n">e1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Amap</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">e2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Amap</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">Amaplst</span><span class="p">)</span>
        <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span>
        <span class="k">return</span> <span class="n">g</span></div>

<div class="viewcode-block" id="Hypergraph.set_state"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.set_state">[docs]</a>    <span class="k">def</span> <span class="nf">set_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allow state_dict updates from outside of class. Use with caution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            key=value pairs to save in state dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_set_default_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Populate state_dict with default values&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;dataframe&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataframe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;edges&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_col</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span><span class="p">),</span>
            <span class="s2">&quot;nodes&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_col</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_col</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_col</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span>
        <span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;snodelg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1">### s: nx.graph</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;sedgelg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;neighbors&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>  <span class="c1">### s: {node: neighbors}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;edge_neighbors&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span>
            <span class="nb">dict</span>
        <span class="p">)</span>  <span class="c1">### s: {edge: edge_neighbors}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;adjacency_matrix&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1">### s: scipy.sparse.csr_matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;edge_adjacency_matrix&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

<div class="viewcode-block" id="Hypergraph.edge_size_dist"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.edge_size_dist">[docs]</a>    <span class="k">def</span> <span class="nf">edge_size_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the size for each edge</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.array</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;edge_size_dist&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">:</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_state</span><span class="p">(</span><span class="n">edge_size_dist</span><span class="o">=</span><span class="n">dist</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dist</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;edge_size_dist&quot;</span><span class="p">]</span></div>

<div class="viewcode-block" id="Hypergraph.degree"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.degree">[docs]</a>    <span class="k">def</span> <span class="nf">degree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of edges of size s that contain node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node : hashable</span>
<span class="sd">            identifier for the node.</span>
<span class="sd">        s : positive integer, optional, default 1</span>
<span class="sd">            smallest size of edge to consider in degree</span>
<span class="sd">        max_size : positive integer or None, optional, default = None</span>
<span class="sd">            largest size of edge to consider in degree</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">         : int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">max_size</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="o">.</span><span class="n">memberships</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">memberships</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="o">.</span><span class="n">memberships</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;=</span> <span class="n">s</span> <span class="ow">and</span> <span class="p">(</span><span class="n">max_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="n">max_size</span><span class="p">):</span>
                    <span class="n">memberships</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">memberships</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.size"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.size">[docs]</a>    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">nodeset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of nodes in nodeset that belong to edge.</span>
<span class="sd">        If nodeset is None then returns the size of edge</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge : hashable</span>
<span class="sd">            The uid of an edge in the hypergraph</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        size : int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nodeset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">nodeset</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">])))</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">])</span></div>

<div class="viewcode-block" id="Hypergraph.number_of_nodes"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.number_of_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">number_of_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodeset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of nodes in nodeset belonging to hypergraph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodeset : an interable of Entities, optional, default = None</span>
<span class="sd">            If None, then return the number of nodes in hypergraph.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        number_of_nodes : int</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">nodeset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodeset</span><span class="p">])</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.number_of_edges"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.number_of_edges">[docs]</a>    <span class="k">def</span> <span class="nf">number_of_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edgeset</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of edges in edgeset belonging to hypergraph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edgeset : an iterable of Entities, optional, default = None</span>
<span class="sd">            If None, then return the number of edges in hypergraph.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        number_of_edges : int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">edgeset</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">([</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edgeset</span><span class="p">])</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.order"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.order">[docs]</a>    <span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of nodes in hypergraph.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        order : int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.dim"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.dim">[docs]</a>    <span class="k">def</span> <span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as size(edge)-1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="Hypergraph.neighbors"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.neighbors">[docs]</a>    <span class="k">def</span> <span class="nf">neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The nodes in hypergraph which share s edge(s) with node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node : hashable or Entity</span>
<span class="sd">            uid for a node in hypergraph or the node Entity</span>

<span class="sd">        s : int, list, optional, default = 1</span>
<span class="sd">            Minimum number of edges shared by neighbors with node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        neighbors : list</span>
<span class="sd">            s-neighbors share at least s edges in the hypergraph</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2"> is not in hypergraph </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;neighbors&quot;</span><span class="p">][</span><span class="n">s</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;neighbors&quot;</span><span class="p">][</span><span class="n">s</span><span class="p">][</span><span class="n">node</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">()</span>
            <span class="n">rdx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">][</span><span class="s2">&quot;nodes&quot;</span><span class="p">]</span>
            <span class="n">jdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">rdx</span> <span class="o">==</span> <span class="n">node</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">jdx</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">idx</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rdx</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">neighbors</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;neighbors&quot;</span><span class="p">][</span><span class="n">s</span><span class="p">][</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbors</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;neighbors&quot;</span><span class="p">][</span><span class="n">s</span><span class="p">][</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">neighbors</span></div>

<div class="viewcode-block" id="Hypergraph.edge_neighbors"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.edge_neighbors">[docs]</a>    <span class="k">def</span> <span class="nf">edge_neighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The edges in hypergraph which share s nodes(s) with edge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edge : hashable or Entity</span>
<span class="sd">            uid for a edge in hypergraph or the edge Entity</span>

<span class="sd">        s : int, list, optional, default = 1</span>
<span class="sd">            Minimum number of nodes shared by neighbors edge node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">         : list</span>
<span class="sd">            List of edge neighbors</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">edge</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Edge is not in hypergraph </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;edge_neighbors&quot;</span><span class="p">][</span><span class="n">s</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;edge_neighbors&quot;</span><span class="p">][</span><span class="n">s</span><span class="p">][</span><span class="n">edge</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">()</span>
            <span class="n">cdx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">][</span><span class="s2">&quot;edges&quot;</span><span class="p">]</span>
            <span class="n">jdx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cdx</span> <span class="o">==</span> <span class="n">edge</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">jdx</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">idx</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">edge_neighbors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cdx</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge_neighbors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">edge_neighbors</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;edge_neighbors&quot;</span><span class="p">][</span><span class="n">s</span><span class="p">][</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge_neighbors</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;edge_neighbors&quot;</span><span class="p">][</span><span class="n">s</span><span class="p">][</span><span class="n">edge</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">return</span> <span class="n">edge_neighbors</span></div>

<div class="viewcode-block" id="Hypergraph.incidence_matrix"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.incidence_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">incidence_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An incidence matrix for the hypergraph indexed by nodes x edges.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weights : bool, default =False</span>
<span class="sd">            If False all nonzero entries are 1.</span>
<span class="sd">            If True and self.static all nonzero entries are filled by</span>
<span class="sd">            self.edges.cell_weights dictionary values.</span>

<span class="sd">        index : boolean, optional, default = False</span>
<span class="sd">            If True return will include a dictionary of node uid : row number</span>
<span class="sd">            and edge uid : column number</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        incidence_matrix : scipy.sparse.csr.csr_matrix or np.ndarray</span>

<span class="sd">        row_index : list</span>
<span class="sd">            index of node ids for rows</span>

<span class="sd">        col_index : list</span>
<span class="sd">            index of edge ids for columns</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sdkey</span> <span class="o">=</span> <span class="s2">&quot;incidence_matrix&quot;</span>
        <span class="k">if</span> <span class="n">weights</span><span class="p">:</span>
            <span class="n">sdkey</span> <span class="o">=</span> <span class="s2">&quot;weighted_&quot;</span> <span class="o">+</span> <span class="n">sdkey</span>

        <span class="k">if</span> <span class="n">sdkey</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="n">sdkey</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataframe</span>
            <span class="n">data_cols</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_col</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">weights</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_cell_weight_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">data_cols</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">),</span>
                        <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">data_cols</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="n">sdkey</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span>

        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">rdx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataframe</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_col</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span>
            <span class="n">cdx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataframe</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_col</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span>

            <span class="k">return</span> <span class="n">M</span><span class="p">,</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">cdx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">M</span></div>

<div class="viewcode-block" id="Hypergraph.adjacency_matrix"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.adjacency_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">adjacency_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">remove_empty_rows</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :term:`s-adjacency matrix` for the hypergraph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        s : int, optional, default = 1</span>

<span class="sd">        index: boolean, optional, default = False</span>
<span class="sd">            if True, will return the index of ids for rows and columns</span>

<span class="sd">        remove_empty_rows: boolean, optional, default = False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adjacency_matrix : scipy.sparse.csr.csr_matrix</span>

<span class="sd">        node_index : list</span>
<span class="sd">            index of ids for rows and columns</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;adjacency_matrix&quot;</span><span class="p">][</span><span class="n">s</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">()</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">M</span> <span class="o">@</span> <span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">A</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;adjacency_matrix&quot;</span><span class="p">][</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">][</span><span class="s2">&quot;nodes&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">A</span></div>

<div class="viewcode-block" id="Hypergraph.edge_adjacency_matrix"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.edge_adjacency_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">edge_adjacency_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :term:`s-adjacency matrix` for the dual hypergraph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        s : int, optional, default 1</span>

<span class="sd">        index: boolean, optional, default = False</span>
<span class="sd">            if True, will return the index of ids for rows and columns</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        edge_adjacency_matrix : scipy.sparse.csr.csr_matrix</span>

<span class="sd">        edge_index : list</span>
<span class="sd">            index of ids for rows and columns</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is also the adjacency matrix for the line graph.</span>
<span class="sd">        Two edges are s-adjacent if they share at least s nodes.</span>
<span class="sd">        If remove_zeros is True will return the auxillary matrix</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;edge_adjacency_matrix&quot;</span><span class="p">][</span><span class="n">s</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">()</span>
            <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">@</span> <span class="p">(</span><span class="n">M</span><span class="p">)</span>
            <span class="n">A</span><span class="o">.</span><span class="n">setdiag</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;edge_adjacency_matrix&quot;</span><span class="p">][</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">][</span><span class="s2">&quot;edges&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">A</span></div>

<div class="viewcode-block" id="Hypergraph.auxiliary_matrix"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.auxiliary_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">auxiliary_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The unweighted :term:`s-edge or node auxiliary matrix` for hypergraph</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        s : int, optional, default = 1</span>
<span class="sd">        node : bool, optional, default = True</span>
<span class="sd">            whether to return based on node or edge adjacencies</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        auxiliary_matrix : scipy.sparse.csr.csr_matrix</span>
<span class="sd">            Node/Edge adjacency matrix with empty rows and columns</span>
<span class="sd">            removed</span>
<span class="sd">        index : np.array</span>
<span class="sd">            row and column index of userids</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">Amap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">Amap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_adjacency_matrix</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">idx</span><span class="p">][:,</span> <span class="n">idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">B</span> <span class="o">=</span> <span class="n">A</span>
        <span class="k">if</span> <span class="n">index</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">B</span><span class="p">,</span> <span class="n">Amap</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">B</span></div>

<div class="viewcode-block" id="Hypergraph.bipartite"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.bipartite">[docs]</a>    <span class="k">def</span> <span class="nf">bipartite</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs the networkX bipartite graph associated to hypergraph.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bipartite : nx.Graph()</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Creates a bipartite networkx graph from hypergraph.</span>
<span class="sd">        The nodes and (hyper)edges of hypergraph become the nodes of bipartite</span>
<span class="sd">        graph. For every (hyper)edge e in the hypergraph and node n in e there</span>
<span class="sd">        is an edge (n,e) in the graph.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">][</span><span class="s2">&quot;nodes&quot;</span><span class="p">]</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">][</span><span class="s2">&quot;edges&quot;</span><span class="p">]</span>
        <span class="n">B</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span> <span class="n">bipartite</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">B</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">bipartite</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">B</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([(</span><span class="n">v</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">B</span></div>

<div class="viewcode-block" id="Hypergraph.dual"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.dual">[docs]</a>    <span class="k">def</span> <span class="nf">dual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">switch_names</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs a new hypergraph with roles of edges and nodes of hypergraph</span>
<span class="sd">        reversed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : hashable, optional</span>

<span class="sd">        switch_names : bool, optional, default = True</span>
<span class="sd">            reverses edge_col and node_col names</span>
<span class="sd">            unless edge_col = &#39;edges&#39; and node_col = &#39;nodes&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : hypergraph</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dfp</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">properties</span><span class="p">)</span>
        <span class="n">dfp</span> <span class="o">=</span> <span class="n">dfp</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">dfp</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">dfp</span><span class="o">.</span><span class="n">level</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">dfp</span> <span class="o">=</span> <span class="n">dfp</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s2">&quot;level&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">])</span>

        <span class="n">edge</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">wt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cell_weight_col</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataframe</span><span class="p">)</span>
        <span class="n">cprops</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">[</span><span class="n">edge</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">wt</span><span class="p">]]</span>

        <span class="n">df</span><span class="p">[[</span><span class="n">edge</span><span class="p">,</span> <span class="n">node</span><span class="p">]]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="n">node</span><span class="p">,</span> <span class="n">edge</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">switch_names</span> <span class="o">==</span> <span class="kc">True</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edge_col</span> <span class="o">==</span> <span class="s2">&quot;edges&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_col</span> <span class="o">==</span> <span class="s2">&quot;nodes&quot;</span>
        <span class="p">):</span>
            <span class="c1"># if switch_names == False or (self._edge_col == &#39;edges&#39; and self._node_col == &#39;nodes&#39;):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">edge</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_col</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_col</span><span class="p">})</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_col</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_col</span>

        <span class="k">return</span> <span class="n">Hypergraph</span><span class="p">(</span>
            <span class="n">df</span><span class="p">,</span>
            <span class="n">edge_col</span><span class="o">=</span><span class="n">edge</span><span class="p">,</span>
            <span class="n">node_col</span><span class="o">=</span><span class="n">node</span><span class="p">,</span>
            <span class="n">cell_weight_col</span><span class="o">=</span><span class="n">wt</span><span class="p">,</span>
            <span class="n">cell_properties</span><span class="o">=</span><span class="n">cprops</span><span class="p">,</span>
            <span class="n">properties</span><span class="o">=</span><span class="n">dfp</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.collapse_edges"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.collapse_edges">[docs]</a>    <span class="k">def</span> <span class="nf">collapse_edges</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">return_equivalence_classes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">use_reps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">return_counts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs a new hypergraph gotten by identifying edges containing the</span>
<span class="sd">        same nodes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : hashable, optional, default = None</span>

<span class="sd">        return_equivalence_classes: boolean, optional, default = False</span>
<span class="sd">            Returns a dictionary of edge equivalence classes keyed by frozen</span>
<span class="sd">            sets of nodes</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new hypergraph : Hypergraph</span>
<span class="sd">            Equivalent edges are collapsed to a single edge named by a</span>
<span class="sd">            representative of the equivalent edges followed by a colon and the</span>
<span class="sd">            number of edges it represents.</span>

<span class="sd">        equivalence_classes : dict</span>
<span class="sd">            A dictionary keyed by representative edge names with values equal</span>
<span class="sd">            to the edges in its equivalence class</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Two edges are identified if their respective elements are the same.</span>
<span class="sd">        Using this as an equivalence relation, the uids of the edges are</span>
<span class="sd">        partitioned into equivalence classes.</span>

<span class="sd">        A single edge from the collapsed edges followed by a colon and the</span>
<span class="sd">        number of elements in its equivalence class as uid for the new edge</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">use_reps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">return_counts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            use_reps ane return_counts are no longer supported keyword</span>
<span class="s2">            arguments and will throw an error in the next release.</span>
<span class="s2">            collapsed hypergraph automatically names collapsed objects by a</span>
<span class="s2">            string &quot;rep:count&quot;</span>
<span class="s2">            &quot;&quot;&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>

        <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">collapse_identical_elements</span><span class="p">(</span>
            <span class="n">return_equivalence_classes</span><span class="o">=</span><span class="n">return_equivalence_classes</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">return_equivalence_classes</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Hypergraph</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">incidence_dict</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span> <span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">Hypergraph</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">incidence_dict</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.collapse_nodes"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.collapse_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">collapse_nodes</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">return_equivalence_classes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">use_reps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">return_counts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Hypergraph</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs a new hypergraph gotten by identifying nodes contained by</span>
<span class="sd">        the same edges</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name: str, optional, default = None</span>

<span class="sd">        return_equivalence_classes: boolean, optional, default = False</span>
<span class="sd">            Returns a dictionary of node equivalence classes keyed by frozen</span>
<span class="sd">            sets of edges</span>

<span class="sd">        use_reps : boolean, optional, default = None</span>
<span class="sd">            [DEPRECATED; WILL BE REMOVED IN NEXT RELEASE] Choose a single element from the</span>
<span class="sd">            collapsed nodes as uid for the new node, otherwise uses a frozen</span>
<span class="sd">            set of the uids of nodes in the equivalence class. If use_reps is True the new nodes have uids given by a</span>
<span class="sd">            tuple of the rep and the count</span>

<span class="sd">        return_counts: boolean, optional, default = None</span>
<span class="sd">            [DEPRECATED; WILL BE REMOVED IN NEXT RELEASE]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new hypergraph : Hypergraph</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Two nodes are identified if their respective memberships are the same.</span>
<span class="sd">        Using this as an equivalence relation, the uids of the nodes are</span>
<span class="sd">        partitioned into equivalence classes. A single member of the</span>
<span class="sd">        equivalence class is chosen to represent the class followed by the</span>
<span class="sd">        number of members of the class.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>

<span class="sd">            &gt;&gt;&gt; data = {&#39;E1&#39;: (&#39;a&#39;, &#39;b&#39;), &#39;E2&#39;: (&#39;a&#39;, &#39;b&#39;)}))</span>
<span class="sd">            &gt;&gt;&gt; h = Hypergraph(data)</span>
<span class="sd">            &gt;&gt;&gt; h.collapse_nodes().incidence_dict</span>
<span class="sd">            {&#39;E1&#39;: [&#39;a: 2&#39;], &#39;E2&#39;: [&#39;a: 2&#39;]}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">use_reps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">return_counts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            use_reps and return_counts are no longer supported keyword arguments and will throw</span>
<span class="s2">            an error in the next release.</span>
<span class="s2">            collapsed hypergraph automatically names collapsed objects by a string &quot;rep:count&quot;</span>
<span class="s2">            &quot;&quot;&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>

        <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">collapse_identical_elements</span><span class="p">(</span>
            <span class="n">return_equivalence_classes</span><span class="o">=</span><span class="n">return_equivalence_classes</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">return_equivalence_classes</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Hypergraph</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">incidence_dict</span><span class="p">)</span><span class="o">.</span><span class="n">dual</span><span class="p">(),</span> <span class="n">temp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">Hypergraph</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">incidence_dict</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">dual</span><span class="p">()</span></div>

<div class="viewcode-block" id="Hypergraph.collapse_nodes_and_edges"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.collapse_nodes_and_edges">[docs]</a>    <span class="k">def</span> <span class="nf">collapse_nodes_and_edges</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">return_equivalence_classes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">use_reps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">return_counts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new hypergraph by collapsing nodes and edges.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        name: str, optional, default = None</span>

<span class="sd">        return_equivalence_classes: boolean, optional, default = False</span>
<span class="sd">            Returns a dictionary of edge equivalence classes keyed by frozen</span>
<span class="sd">            sets of nodes</span>

<span class="sd">        use_reps: boolean, optional, default = None</span>
<span class="sd">            [DEPRECATED; WILL BE REMOVED IN NEXT RELEASE] Choose a single element from the collapsed elements as a</span>
<span class="sd">            representative. If use_reps is True, the new elements are keyed by a tuple of the</span>
<span class="sd">            rep and the count.</span>

<span class="sd">        return_counts: boolean, optional, default = None</span>
<span class="sd">            [DEPRECATED; WILL BE REMOVED IN NEXT RELEASE]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new hypergraph : Hypergraph</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Collapses the Nodes and Edges of EntitySets. Two nodes(edges) are</span>
<span class="sd">        duplicates if their respective memberships(elements) are the same.</span>
<span class="sd">        Using this as an equivalence relation, the uids of the nodes(edges)</span>
<span class="sd">        are partitioned into equivalence classes. A single member of the</span>
<span class="sd">        equivalence class is chosen to represent the class followed by the</span>
<span class="sd">        number of members of the class.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>

<span class="sd">            &gt;&gt;&gt; data = {&#39;E1&#39;: (&#39;a&#39;, &#39;b&#39;), &#39;E2&#39;: (&#39;a&#39;, &#39;b&#39;)}</span>
<span class="sd">            &gt;&gt;&gt; h = Hypergraph(data)</span>
<span class="sd">            &gt;&gt;&gt; h.incidence_dict</span>
<span class="sd">            {&#39;E1&#39;: [&#39;a&#39;, &#39;b&#39;], &#39;E2&#39;: [&#39;a&#39;, &#39;b&#39;]}</span>
<span class="sd">            &gt;&gt;&gt; h.collapse_nodes_and_edges().incidence_dict</span>
<span class="sd">            {&#39;E1: 2&#39;: [&#39;a: 2&#39;]}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">use_reps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">return_counts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">            use_reps and return_counts are no longer supported keyword</span>
<span class="s2">            arguments and will throw an error in the next release.</span>
<span class="s2">            collapsed hypergraph automatically names collapsed objects by a</span>
<span class="s2">            string &quot;rep:count&quot;</span>
<span class="s2">            &quot;&quot;&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_equivalence_classes</span><span class="p">:</span>
            <span class="n">temp</span><span class="p">,</span> <span class="n">neq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapse_nodes</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;temp&quot;</span><span class="p">,</span> <span class="n">return_equivalence_classes</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">ntemp</span><span class="p">,</span> <span class="n">eeq</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">collapse_edges</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">return_equivalence_classes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ntemp</span><span class="p">,</span> <span class="n">neq</span><span class="p">,</span> <span class="n">eeq</span>

        <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collapse_nodes</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;temp&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">temp</span><span class="o">.</span><span class="n">collapse_edges</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.restrict_to_nodes"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.restrict_to_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">restrict_to_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;New hypergraph gotten by restricting to nodes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes : Iterable</span>
<span class="sd">            nodeids to restrict to</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : hnx. Hypergraph</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">][</span><span class="s2">&quot;nodes&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.restrict_to_edges"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.restrict_to_edges">[docs]</a>    <span class="k">def</span> <span class="nf">restrict_to_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;New hypergraph gotten by restricting to edges</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edges : Iterable</span>
<span class="sd">            edgeids to restrict to</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hnx.Hypergraph</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">][</span><span class="s2">&quot;edges&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.remove_edges"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.remove_edges">[docs]</a>    <span class="k">def</span> <span class="nf">remove_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.remove_nodes"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.remove_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">remove_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.remove"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a new hypergraph with nodes and/or edges indexed by keys</span>
<span class="sd">        removed. More efficient for creating a restricted hypergraph if the</span>
<span class="sd">        restricted set is greater than what is being removed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keys : list | tuple | set | Hashable</span>
<span class="sd">            node and/or edge id(s) to restrict to</span>
<span class="sd">        level : None, optional</span>
<span class="sd">            Enter 0 to remove edges with ids in keys.</span>
<span class="sd">            Enter 1 to remove nodes with ids in keys.</span>
<span class="sd">            If None then all objects in nodes and edges with the id will</span>
<span class="sd">            be removed.</span>
<span class="sd">        name : str, optional</span>
<span class="sd">            Name of new hypergraph</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : hnx.Hypergraph</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rdfprop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">rdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
            <span class="n">nkeys</span> <span class="o">=</span> <span class="n">keys</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">Hashable</span><span class="p">):</span>
            <span class="n">nkeys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="n">nkeys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`keys` parameter must be list | tuple | set | Hashable&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">kdx</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nkeys</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">][</span><span class="s2">&quot;edges&quot;</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kdx</span><span class="p">:</span>
                <span class="n">rdfprop</span> <span class="o">=</span> <span class="n">rdfprop</span><span class="o">.</span><span class="n">drop</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
            <span class="n">rdf</span> <span class="o">=</span> <span class="n">rdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="p">(</span><span class="n">rdf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_col</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">kdx</span><span class="p">))]</span>
        <span class="k">elif</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">kdx</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nkeys</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_state_dict</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">][</span><span class="s2">&quot;nodes&quot;</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kdx</span><span class="p">:</span>
                <span class="n">rdfprop</span> <span class="o">=</span> <span class="n">rdfprop</span><span class="o">.</span><span class="n">drop</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
            <span class="n">rdf</span> <span class="o">=</span> <span class="n">rdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="p">(</span><span class="n">rdf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_col</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">kdx</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rdfprop</span> <span class="o">=</span> <span class="n">rdfprop</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
            <span class="n">kdx</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nkeys</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">rdfprop</span><span class="o">.</span><span class="n">id</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
            <span class="n">rdfprop</span> <span class="o">=</span> <span class="n">rdfprop</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">)</span>
            <span class="n">rdfprop</span> <span class="o">=</span> <span class="n">rdfprop</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">kdx</span><span class="p">)</span>
            <span class="n">rdf</span> <span class="o">=</span> <span class="n">rdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="p">(</span><span class="n">rdf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_col</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">kdx</span><span class="p">))]</span>
            <span class="n">rdf</span> <span class="o">=</span> <span class="n">rdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="p">(</span><span class="n">rdf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_col</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">kdx</span><span class="p">))]</span>

        <span class="k">return</span> <span class="n">Hypergraph</span><span class="p">(</span>
            <span class="n">setsystem</span><span class="o">=</span><span class="n">rdf</span><span class="p">,</span>
            <span class="n">edge_col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_edge_col</span><span class="p">,</span>
            <span class="n">node_col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_node_col</span><span class="p">,</span>
            <span class="n">cell_weight_col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cell_weight_col</span><span class="p">,</span>
            <span class="n">misc_cell_properties_col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">_misc_cell_props_col</span><span class="p">,</span>
            <span class="n">properties</span><span class="o">=</span><span class="n">rdfprop</span><span class="p">,</span>
            <span class="n">misc_properties_col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">_misc_props_col</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.toplexes"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.toplexes">[docs]</a>    <span class="k">def</span> <span class="nf">toplexes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a :term:`simple hypergraph` corresponding to self.</span>

<span class="sd">        Warning</span>
<span class="sd">        -------</span>
<span class="sd">        Collapsing is no longer supported inside the toplexes method. Instead</span>
<span class="sd">        generate a new collapsed hypergraph and compute the toplexes of the</span>
<span class="sd">        new hypergraph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name: str, optional, default = None</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">thdict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="n">thdict</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>

        <span class="n">tops</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">old_tops</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tops</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">top</span> <span class="ow">in</span> <span class="n">old_tops</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">thdict</span><span class="p">[</span><span class="n">e</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">thdict</span><span class="p">[</span><span class="n">top</span><span class="p">]):</span>
                    <span class="n">flag</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>

                <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">thdict</span><span class="p">[</span><span class="n">top</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">thdict</span><span class="p">[</span><span class="n">e</span><span class="p">]):</span>
                    <span class="n">tops</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
                <span class="n">tops</span> <span class="o">+=</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">restrict_to_edges</span><span class="p">(</span><span class="n">tops</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.is_connected"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.is_connected">[docs]</a>    <span class="k">def</span> <span class="nf">is_connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if hypergraph is :term:`s-connected &lt;s-connected,</span>
<span class="sd">        s-node-connected&gt;`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        s: int, optional, default 1</span>

<span class="sd">        edges: boolean, optional, default = False</span>
<span class="sd">            If True, will determine if s-edge-connected.</span>
<span class="sd">            For s=1 s-edge-connected is the same as s-connected.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_connected : boolean</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        A hypergraph is s node connected if for any two nodes v0,vn</span>
<span class="sd">        there exists a sequence of nodes v0,v1,v2,...,v(n-1),vn</span>
<span class="sd">        such that every consecutive pair of nodes v(i),v(i+1)</span>
<span class="sd">        share at least s edges.</span>

<span class="sd">        A hypergraph is s edge connected if for any two edges e0,en</span>
<span class="sd">        there exists a sequence of edges e0,e1,e2,...,e(n-1),en</span>
<span class="sd">        such that every consecutive pair of edges e(i),e(i+1)</span>
<span class="sd">        share at least s nodes.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_linegraph</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">)</span>
        <span class="n">is_connected</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">is_connected</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_connected</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXPointlessConcept</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Graph is null; &quot;</span><span class="p">)</span>
            <span class="n">is_connected</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">is_connected</span></div>

<div class="viewcode-block" id="Hypergraph.singletons"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.singletons">[docs]</a>    <span class="k">def</span> <span class="nf">singletons</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of singleton edges. A singleton edge is an edge of</span>
<span class="sd">        size 1 with a node of degree 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        singles : list</span>
<span class="sd">            A list of edge uids.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">M</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">cdict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">incidence_matrix</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># which axis has fewest members? if 1 then columns</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># we add down the row index if there are fewer columns</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">singles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># index along opposite axis with one entry each</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="n">cols</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))[(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">]:</span>
            <span class="c1"># if the singleton entry in that column is also</span>
            <span class="c1"># singleton in its row find the entry</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
                <span class="c1"># and get its sum</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">getrow</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
                <span class="c1"># if this is also 1 then the entry in r,c represents a</span>
                <span class="c1"># singleton so we want to change that entry to 0 and</span>
                <span class="c1"># remove the row. this means we want to remove the</span>
                <span class="c1"># edge corresponding to c</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">singles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cdict</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># switch the role of r and c</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">getrow</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">getcol</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">singles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cdict</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">singles</span></div>

<div class="viewcode-block" id="Hypergraph.remove_singletons"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.remove_singletons">[docs]</a>    <span class="k">def</span> <span class="nf">remove_singletons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs clone of hypergraph with singleton edges removed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new hypergraph : Hypergraph</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">singletons</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">singletons</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">singletons</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">):</span>
            <span class="n">E</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">singletons</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">restrict_to_edges</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">singletons</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.s_connected_components"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.s_connected_components">[docs]</a>    <span class="k">def</span> <span class="nf">s_connected_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_singletons</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a generator for the :term:`s-edge-connected components</span>
<span class="sd">        &lt;s-edge-connected component&gt;`</span>
<span class="sd">        or the :term:`s-node-connected components &lt;s-connected component,</span>
<span class="sd">        s-node-connected component&gt;` of the hypergraph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        s : int, optional, default 1</span>

<span class="sd">        edges : boolean, optional, default = True</span>
<span class="sd">            If True will return edge components, if False will return node</span>
<span class="sd">            components</span>
<span class="sd">        return_singletons : bool, optional, default = False</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If edges=True, this method returns the s-edge-connected components as</span>
<span class="sd">        lists of lists of edge uids.</span>
<span class="sd">        An s-edge-component has the property that for any two edges e1 and e2</span>
<span class="sd">        there is a sequence of edges starting with e1 and ending with e2</span>
<span class="sd">        such that pairwise adjacent edges in the sequence intersect in at least</span>
<span class="sd">        s nodes. If s=1 these are the path components of the hypergraph.</span>

<span class="sd">        If edges=False this method returns s-node-connected components.</span>
<span class="sd">        A list of sets of uids of the nodes which are s-walk connected.</span>
<span class="sd">        Two nodes v1 and v2 are s-walk-connected if there is a</span>
<span class="sd">        sequence of nodes starting with v1 and ending with v2 such that</span>
<span class="sd">        pairwise adjacent nodes in the sequence share s edges. If s=1 these</span>
<span class="sd">        are the path components of the hypergraph.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">            &gt;&gt;&gt; S = {&#39;A&#39;:{1,2,3},&#39;B&#39;:{2,3,4},&#39;C&#39;:{5,6},&#39;D&#39;:{6}}</span>
<span class="sd">            &gt;&gt;&gt; H = Hypergraph(S)</span>

<span class="sd">            &gt;&gt;&gt; list(H.s_components(edges=True))</span>
<span class="sd">            [{&#39;C&#39;, &#39;D&#39;}, {&#39;A&#39;, &#39;B&#39;}]</span>
<span class="sd">            &gt;&gt;&gt; list(H.s_components(edges=False))</span>
<span class="sd">            [{1, 2, 3, 4}, {5, 6}]</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        s_connected_components : iterator</span>
<span class="sd">            Iterator returns sets of uids of the edges (or nodes) in the</span>
<span class="sd">            s-edge(node) components of hypergraph.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_linegraph</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">g</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">return_singletons</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">yield</span> <span class="n">c</span></div>

<div class="viewcode-block" id="Hypergraph.s_component_subgraphs"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.s_component_subgraphs">[docs]</a>    <span class="k">def</span> <span class="nf">s_component_subgraphs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_singletons</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Returns a generator for the induced subgraphs of s_connected</span>
<span class="sd">        components. Removes singletons unless return_singletons is set to True.</span>
<span class="sd">        Computed using s-linegraph generated either by the hypergraph</span>
<span class="sd">        (edges=True) or its dual (edges = False)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        s : int, optional, default 1</span>

<span class="sd">        edges : boolean, optional, edges=False</span>
<span class="sd">            Determines if edge or node components are desired. Returns</span>
<span class="sd">            subgraphs equal to the hypergraph restricted to each set of</span>
<span class="sd">            nodes(edges) in the s-connected components or s-edge-connected</span>
<span class="sd">            components</span>
<span class="sd">        return_singletons : bool, optional</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        s_component_subgraphs : iterator</span>
<span class="sd">            Iterator returns subgraphs generated by the edges (or nodes) in the</span>
<span class="sd">            s-edge(node) components of hypergraph.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">s_components</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span> <span class="n">return_singletons</span><span class="o">=</span><span class="n">return_singletons</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">edges</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">restrict_to_edges</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">restrict_to_nodes</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.s_components"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.s_components">[docs]</a>    <span class="k">def</span> <span class="nf">s_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_singletons</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as s_connected_components</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        s_connected_components</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_connected_components</span><span class="p">(</span>
            <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span> <span class="n">return_singletons</span><span class="o">=</span><span class="n">return_singletons</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.connected_components"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.connected_components">[docs]</a>    <span class="k">def</span> <span class="nf">connected_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as :meth:`s_connected_components` with s=1, but nodes are returned</span>
<span class="sd">        by default. Return iterator.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        s_connected_components</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_connected_components</span><span class="p">(</span><span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">,</span> <span class="n">return_singletons</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.connected_component_subgraphs"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.connected_component_subgraphs">[docs]</a>    <span class="k">def</span> <span class="nf">connected_component_subgraphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_singletons</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as :meth:`s_component_subgraphs` with s=1. Returns iterator</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        s_component_subgraphs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_component_subgraphs</span><span class="p">(</span>
            <span class="n">return_singletons</span><span class="o">=</span><span class="n">return_singletons</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.components"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.components">[docs]</a>    <span class="k">def</span> <span class="nf">components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as :meth:`s_connected_components` with s=1, but nodes are returned</span>
<span class="sd">        by default. Return iterator.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        s_connected_components</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_connected_components</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="n">edges</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.component_subgraphs"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.component_subgraphs">[docs]</a>    <span class="k">def</span> <span class="nf">component_subgraphs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_singletons</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as :meth:`s_components_subgraphs` with s=1. Returns iterator.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        s_component_subgraphs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_component_subgraphs</span><span class="p">(</span>
            <span class="n">return_singletons</span><span class="o">=</span><span class="n">return_singletons</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.node_diameters"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.node_diameters">[docs]</a>    <span class="k">def</span> <span class="nf">node_diameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the node diameters of the connected components in hypergraph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        list of the diameters of the s-components and</span>
<span class="sd">        list of the s-component nodes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">coldict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_scipy_sparse_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">diams</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">comps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
            <span class="n">diamc</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">diameter</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
                <span class="n">temp</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">coldict</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>
            <span class="n">comps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
            <span class="n">diams</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">diamc</span><span class="p">)</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">diams</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">diams</span><span class="p">[</span><span class="n">loc</span><span class="p">],</span> <span class="n">diams</span><span class="p">,</span> <span class="n">comps</span></div>

<div class="viewcode-block" id="Hypergraph.edge_diameters"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.edge_diameters">[docs]</a>    <span class="k">def</span> <span class="nf">edge_diameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the edge diameters of the s_edge_connected component subgraphs</span>
<span class="sd">        in hypergraph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        s : int, optional, default 1</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        maximum diameter : int</span>

<span class="sd">        list of diameters : list</span>
<span class="sd">            List of edge_diameters for s-edge component subgraphs in hypergraph</span>

<span class="sd">        list of component : list</span>
<span class="sd">            List of the edge uids in the s-edge component subgraphs.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">coldict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_adjacency_matrix</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_scipy_sparse_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">diams</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">comps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
            <span class="n">diamc</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">diameter</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
                <span class="n">temp</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">coldict</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>
            <span class="n">comps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>
            <span class="n">diams</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">diamc</span><span class="p">)</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">diams</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">diams</span><span class="p">[</span><span class="n">loc</span><span class="p">],</span> <span class="n">diams</span><span class="p">,</span> <span class="n">comps</span></div>

<div class="viewcode-block" id="Hypergraph.diameter"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.diameter">[docs]</a>    <span class="k">def</span> <span class="nf">diameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the length of the longest shortest s-walk between nodes in</span>
<span class="sd">        hypergraph</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        s : int, optional, default 1</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        diameter : int</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        HyperNetXError</span>
<span class="sd">            If hypergraph is not s-edge-connected</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Two nodes are s-adjacent if they share s edges.</span>
<span class="sd">        Two nodes v_start and v_end are s-walk connected if there is a</span>
<span class="sd">        sequence of nodes v_start, v_1, v_2, ... v_n-1, v_end such that</span>
<span class="sd">        consecutive nodes are s-adjacent. If the graph is not connected,</span>
<span class="sd">        an error will be raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_scipy_sparse_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_connected</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">diameter</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

        <span class="k">raise</span> <span class="n">HyperNetXError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Hypergraph is not s-connected. s=</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.edge_diameter"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.edge_diameter">[docs]</a>    <span class="k">def</span> <span class="nf">edge_diameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the length of the longest shortest s-walk between edges in</span>
<span class="sd">        hypergraph</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        s : int, optional, default 1</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        edge_diameter : int</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        HyperNetXError</span>
<span class="sd">            If hypergraph is not s-edge-connected</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Two edges are s-adjacent if they share s nodes.</span>
<span class="sd">        Two nodes e_start and e_end are s-walk connected if there is a</span>
<span class="sd">        sequence of edges e_start, e_1, e_2, ... e_n-1, e_end such that</span>
<span class="sd">        consecutive edges are s-adjacent. If the graph is not connected, an</span>
<span class="sd">        error will be raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_adjacency_matrix</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_scipy_sparse_matrix</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_connected</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">diameter</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

        <span class="k">raise</span> <span class="n">HyperNetXError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Hypergraph is not s-connected. s=</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.distance"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.distance">[docs]</a>    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the shortest s-walk distance between two nodes in the</span>
<span class="sd">        hypergraph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source : node.uid or node</span>
<span class="sd">            a node in the hypergraph</span>

<span class="sd">        target : node.uid or node</span>
<span class="sd">            a node in the hypergraph</span>

<span class="sd">        s : positive integer</span>
<span class="sd">            the number of edges</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        s-walk distance : int</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        edge_distance</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The s-distance is the shortest s-walk length between the nodes.</span>
<span class="sd">        An s-walk between nodes is a sequence of nodes that pairwise share</span>
<span class="sd">        at least s edges. The length of the shortest s-walk is 1 less than</span>
<span class="sd">        the number of nodes in the path sequence.</span>

<span class="sd">        Uses the networkx shortest_path_length method on the graph</span>
<span class="sd">        generated by the s-adjacency matrix.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_linegraph</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">NetworkXNoPath</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">NodeNotFound</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No </span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">-path between </span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

        <span class="k">return</span> <span class="n">dist</span></div>

<div class="viewcode-block" id="Hypergraph.edge_distance"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.edge_distance">[docs]</a>    <span class="k">def</span> <span class="nf">edge_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;XX TODO: still need to return path and translate into user defined</span>
<span class="sd">        nodes and edges Returns the shortest s-walk distance between two edges</span>
<span class="sd">        in the hypergraph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source : edge.uid or edge</span>
<span class="sd">            an edge in the hypergraph</span>

<span class="sd">        target : edge.uid or edge</span>
<span class="sd">            an edge in the hypergraph</span>

<span class="sd">        s : positive integer</span>
<span class="sd">            the number of intersections between pairwise consecutive edges</span>

<span class="sd">        TODO: add edge weights</span>
<span class="sd">        weight : None or string, optional, default = None</span>
<span class="sd">            if None then all edges have weight 1. If string then edge attribute</span>
<span class="sd">            string is used if available.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        s- walk distance : the shortest s-walk edge distance</span>
<span class="sd">            A shortest s-walk is computed as a sequence of edges,</span>
<span class="sd">            the s-walk distance is the number of edges in the sequence</span>
<span class="sd">            minus 1. If no such path exists returns np.inf.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        distance</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">            The s-distance is the shortest s-walk length between the edges.</span>
<span class="sd">            An s-walk between edges is a sequence of edges such that</span>
<span class="sd">            consecutive pairwise edges intersect in at least s nodes. The</span>
<span class="sd">            length of the shortest s-walk is 1 less than the number of edges</span>
<span class="sd">            in the path sequence.</span>

<span class="sd">            Uses the networkx shortest_path_length method on the graph</span>
<span class="sd">            generated by the s-edge_adjacency matrix.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_linegraph</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">edge_dist</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">NetworkXNoPath</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">NodeNotFound</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No </span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">-path between </span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">edge_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

        <span class="k">return</span> <span class="n">edge_dist</span></div>

<div class="viewcode-block" id="Hypergraph.incidence_dataframe"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.incidence_dataframe">[docs]</a>    <span class="k">def</span> <span class="nf">incidence_dataframe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sort_rows</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort_columns</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cell_weights</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a pandas dataframe for hypergraph indexed by the nodes and</span>
<span class="sd">        with column headers given by the edge names.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sort_rows : bool, optional, default =True</span>
<span class="sd">            sort rows based on hashable node names</span>
<span class="sd">        sort_columns : bool, optional, default =True</span>
<span class="sd">            sort columns based on hashable edge names</span>
<span class="sd">        cell_weights : bool, optional, default =True</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">## An entity dataframe is already an incidence dataframe.</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">pivot</span><span class="p">(</span>
            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="o">.</span><span class="n">_data_cols</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="o">.</span><span class="n">_data_cols</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="o">.</span><span class="n">_cell_weight_col</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sort_rows</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="s2">&quot;index&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sort_columns</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="s2">&quot;columns&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cell_weights</span><span class="p">:</span>
            <span class="n">df</span><span class="p">[</span><span class="n">df</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">df</span></div>

<div class="viewcode-block" id="Hypergraph.from_bipartite"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.from_bipartite">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="nd">@warn_nwhy</span>
    <span class="k">def</span> <span class="nf">from_bipartite</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">set_names</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;edges&quot;</span><span class="p">,</span> <span class="s2">&quot;nodes&quot;</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Static method creates a Hypergraph from a bipartite graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        B: nx.Graph()</span>
<span class="sd">            A networkx bipartite graph. Each node in the graph has a property</span>
<span class="sd">            &#39;bipartite&#39; taking the value of 0 or 1 indicating a 2-coloring of</span>
<span class="sd">            the graph.</span>

<span class="sd">        set_names: iterable of length 2, optional, default = [&#39;edges&#39;,&#39;nodes&#39;]</span>
<span class="sd">            Category names assigned to the graph nodes associated to each</span>
<span class="sd">            bipartite set</span>

<span class="sd">        name: hashable, optional</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">         : Hypergraph</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        A partition for the nodes in a bipartite graph generates a hypergraph.</span>

<span class="sd">            &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">            &gt;&gt;&gt; B = nx.Graph()</span>
<span class="sd">            &gt;&gt;&gt; B.add_nodes_from([1, 2, 3, 4], bipartite=0)</span>
<span class="sd">            &gt;&gt;&gt; B.add_nodes_from([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], bipartite=1)</span>
<span class="sd">            &gt;&gt;&gt; B.add_edges_from([(1, &#39;a&#39;), (1, &#39;b&#39;), (2, &#39;b&#39;), (2, &#39;c&#39;), /</span>
<span class="sd">                (3, &#39;c&#39;), (4, &#39;a&#39;)])</span>
<span class="sd">            &gt;&gt;&gt; H = Hypergraph.from_bipartite(B)</span>
<span class="sd">            &gt;&gt;&gt; H.nodes, H.edges</span>
<span class="sd">            # output: (EntitySet(_:Nodes,[1, 2, 3, 4],{}), /</span>
<span class="sd">            # EntitySet(_:Edges,[&#39;b&#39;, &#39;c&#39;, &#39;a&#39;],{}))</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">B</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;bipartite&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">bipartite</span><span class="o">.</span><span class="n">is_bipartite_node_set</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">HyperNetXError</span><span class="p">(</span>
                <span class="s2">&quot;Error: Method requires a 2-coloring of a bipartite graph.&quot;</span>
            <span class="p">)</span>

        <span class="n">elist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">edges</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                <span class="n">elist</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">elist</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">elist</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">set_names</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Hypergraph</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.from_incidence_matrix"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.from_incidence_matrix">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_incidence_matrix</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">M</span><span class="p">,</span>
        <span class="n">node_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">edge_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">node_label</span><span class="o">=</span><span class="s2">&quot;nodes&quot;</span><span class="p">,</span>
        <span class="n">edge_label</span><span class="o">=</span><span class="s2">&quot;edges&quot;</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as from_numpy_array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Hypergraph</span><span class="o">.</span><span class="n">from_numpy_array</span><span class="p">(</span>
            <span class="n">M</span><span class="p">,</span>
            <span class="n">node_names</span><span class="o">=</span><span class="n">node_names</span><span class="p">,</span>
            <span class="n">edge_names</span><span class="o">=</span><span class="n">edge_names</span><span class="p">,</span>
            <span class="n">node_label</span><span class="o">=</span><span class="n">node_label</span><span class="p">,</span>
            <span class="n">edge_label</span><span class="o">=</span><span class="n">edge_label</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.from_numpy_array"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.from_numpy_array">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="nd">@warn_nwhy</span>
    <span class="k">def</span> <span class="nf">from_numpy_array</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">M</span><span class="p">,</span>
        <span class="n">node_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">edge_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">node_label</span><span class="o">=</span><span class="s2">&quot;nodes&quot;</span><span class="p">,</span>
        <span class="n">edge_label</span><span class="o">=</span><span class="s2">&quot;edges&quot;</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a hypergraph from a real valued matrix represented as a 2 dimensionsl numpy array.</span>
<span class="sd">        The matrix is converted to a matrix of 0&#39;s and 1&#39;s so that any truthy cells are converted to 1&#39;s and</span>
<span class="sd">        all others to 0&#39;s.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        M : real valued array-like object, 2 dimensions</span>
<span class="sd">            representing a real valued matrix with rows corresponding to nodes and columns to edges</span>

<span class="sd">        node_names : object, array-like, default=None</span>
<span class="sd">            List of node names must be the same length as M.shape[0].</span>
<span class="sd">            If None then the node names correspond to row indices with &#39;v&#39; prepended.</span>

<span class="sd">        edge_names : object, array-like, default=None</span>
<span class="sd">            List of edge names must have the same length as M.shape[1].</span>
<span class="sd">            If None then the edge names correspond to column indices with &#39;e&#39; prepended.</span>

<span class="sd">        name : hashable</span>

<span class="sd">        key : (optional) function</span>
<span class="sd">            boolean function to be evaluated on each cell of the array,</span>
<span class="sd">            must be applicable to numpy.array</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">         : Hypergraph</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        The constructor does not generate empty edges.</span>
<span class="sd">        All zero columns in M are removed and the names corresponding to these</span>
<span class="sd">        edges are discarded.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create names for nodes and edges</span>
        <span class="c1"># Validate the size of the node and edge arrays</span>

        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">HyperNetXError</span><span class="p">(</span><span class="s2">&quot;Input requires a 2 dimensional numpy array&quot;</span><span class="p">)</span>
        <span class="c1"># apply boolean key if available</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">key</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">node_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nodenames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_names</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodenames</span><span class="p">)</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">HyperNetXError</span><span class="p">(</span>
                    <span class="s2">&quot;Number of node names does not match number of rows.&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nodenames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;v</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])])</span>

        <span class="k">if</span> <span class="n">edge_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edgenames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">edge_names</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edgenames</span><span class="p">)</span> <span class="o">!=</span> <span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">HyperNetXError</span><span class="p">(</span>
                    <span class="s2">&quot;Number of edge_names does not match number of columns.&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edgenames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;e</span><span class="si">{</span><span class="n">jdx</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">jdx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">edgenames</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">nodenames</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Hypergraph</span><span class="o">.</span><span class="n">from_incidence_dataframe</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Hypergraph.from_incidence_dataframe"><a class="viewcode-back" href="../../../classes/classes.html#classes.Hypergraph.from_incidence_dataframe">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="nd">@warn_nwhy</span>
    <span class="k">def</span> <span class="nf">from_incidence_dataframe</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">rows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">edge_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;edges&quot;</span><span class="p">,</span>
        <span class="n">node_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;nodes&quot;</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fillna</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">transpose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">transforms</span><span class="o">=</span><span class="p">[],</span>
        <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">return_only_dataframe</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a hypergraph from a Pandas Dataframe object, which has values equal</span>
<span class="sd">        to the incidence matrix of a hypergraph. Its index will identify the nodes</span>
<span class="sd">        and its columns will identify its edges.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df : Pandas.Dataframe</span>
<span class="sd">            a real valued dataframe with a single index</span>

<span class="sd">        columns : (optional) list, default = None</span>
<span class="sd">            restricts df to the columns with headers in this list.</span>

<span class="sd">        rows : (optional) list, default = None</span>
<span class="sd">            restricts df to the rows indexed by the elements in this list.</span>

<span class="sd">        name : (optional) string, default = None</span>

<span class="sd">        fillna : float, default = 0</span>
<span class="sd">            a real value to place in empty cell, all-zero columns will not</span>
<span class="sd">            generate an edge.</span>

<span class="sd">        transpose : (optional) bool, default = False</span>
<span class="sd">            option to transpose the dataframe, in this case df.Index will</span>
<span class="sd">            identify the edges and df.columns will identify the nodes, transpose is</span>
<span class="sd">            applied before transforms and key</span>

<span class="sd">        transforms : (optional) list, default = []</span>
<span class="sd">            optional list of transformations to apply to each column,</span>
<span class="sd">            of the dataframe using pd.DataFrame.apply().</span>
<span class="sd">            Transformations are applied in the order they are</span>
<span class="sd">            given (ex. abs). To apply transforms to rows or for additional</span>
<span class="sd">            functionality, consider transforming df using pandas.DataFrame</span>
<span class="sd">            methods prior to generating the hypergraph.</span>

<span class="sd">        key : (optional) function, default = None</span>
<span class="sd">            boolean function to be applied to dataframe. will be applied to</span>
<span class="sd">            entire dataframe.</span>

<span class="sd">        return_only_dataframe : (optional) bool, default = False</span>
<span class="sd">            to use the incidence_dataframe with cell_properties or properties, set this</span>
<span class="sd">            to true and use it as the setsystem in the Hypergraph constructor.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        from_numpy_array</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        : Hypergraph</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">HyperNetXError</span><span class="p">(</span><span class="s2">&quot;Error: Input object must be a pandas dataframe.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">columns</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">rows</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">rows</span><span class="p">]</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fillna</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">transpose</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transforms</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">key</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">values</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">values</span> <span class="o">*</span> <span class="mi">1</span>

        <span class="n">cols</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span>
        <span class="n">CM</span> <span class="o">=</span> <span class="n">coo_matrix</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="n">CM</span><span class="o">.</span><span class="n">row</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="p">[</span><span class="n">rows</span><span class="p">[</span><span class="n">c1</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c1</span><span class="p">))]</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">CM</span><span class="o">.</span><span class="n">col</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="p">[</span><span class="n">cols</span><span class="p">[</span><span class="n">c2</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">c2</span><span class="p">))]</span>
        <span class="n">c3</span> <span class="o">=</span> <span class="n">CM</span><span class="o">.</span><span class="n">data</span>

        <span class="n">dfnew</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="n">edge_col</span><span class="p">:</span> <span class="n">c2</span><span class="p">,</span> <span class="n">node_col</span><span class="p">:</span> <span class="n">c1</span><span class="p">,</span> <span class="s2">&quot;cell_weights&quot;</span><span class="p">:</span> <span class="n">c3</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">return_only_dataframe</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dfnew</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Hypergraph</span><span class="p">(</span>
                <span class="n">dfnew</span><span class="p">,</span>
                <span class="n">edge_col</span><span class="o">=</span><span class="n">edge_col</span><span class="p">,</span>
                <span class="n">node_col</span><span class="o">=</span><span class="n">node_col</span><span class="p">,</span>
                <span class="n">weights</span><span class="o">=</span><span class="s2">&quot;cell_weights&quot;</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023 Battelle Memorial Institute.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>