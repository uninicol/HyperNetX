<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Modularity and Clustering &mdash; HyperNetX 2.0.5 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/copybutton.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script src="_static/clipboard.min.js"></script>
        <script src="_static/copybutton.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Publications" href="publications.html" />
    <link rel="prev" title="Hypernetx-Widget" href="widget.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            HyperNetX
              <img src="_static/hnx_logo_smaller.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                2.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview/index.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installing HyperNetX</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="core.html">HyperNetX Packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="hypergraph101.html">A Gentle Introduction to Hypergraph Mathematics</a></li>
<li class="toctree-l1"><a class="reference internal" href="hypconstructors.html">Hypergraph Constructors</a></li>
<li class="toctree-l1"><a class="reference internal" href="widget.html">Visualization Widget</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Algorithms: Modularity and Clustering</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#installation">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-the-tool">Using the Tool</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#precomputation">Precomputation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id1">Modularity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#two-section-graph">Two-section graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="#clustering-algorithms">Clustering Algorithms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#other-features">Other Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="publications.html">Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">HyperNetX</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Modularity and Clustering</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/modularity.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="modularity-and-clustering">
<span id="modularity"></span><h1>Modularity and Clustering<a class="headerlink" href="#modularity-and-clustering" title="Permalink to this heading"></a></h1>
<a class="reference internal image-reference" href="_images/ModularityScreenShot.png"><img alt="_images/ModularityScreenShot.png" class="align-right" src="_images/ModularityScreenShot.png" style="width: 300px;" /></a>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this heading"></a></h2>
<p>The hypergraph_modularity submodule in HNX provides functions to compute <strong>hypergraph modularity</strong> for a
given partition of the vertices in a hypergraph. In general, higher modularity indicates a better
partitioning of the vertices into dense communities.</p>
<p>Two functions to generate such hypergraph
partitions are provided: <strong>Kumar’s</strong> algorithm, and the simple <strong>Last-Step</strong> refinement algorithm.</p>
<p>The submodule also provides a function to generate the <strong>two-section graph</strong> for a given hypergraph which can then be used to find
vertex partitions via graph-based algorithms.</p>
</section>
<section id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this heading"></a></h2>
<p>Since it is part of HNX, no extra installation is required.
The submodule can be imported as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">hypernetx.algorithms.hypergraph_modularity</span> <span class="k">as</span> <span class="nn">hmod</span>
</pre></div>
</div>
</section>
<section id="using-the-tool">
<h2>Using the Tool<a class="headerlink" href="#using-the-tool" title="Permalink to this heading"></a></h2>
<section id="precomputation">
<h3>Precomputation<a class="headerlink" href="#precomputation" title="Permalink to this heading"></a></h3>
<p>In order to make the computation of hypergraph modularity more efficient, some quantities need to be pre-computed.
Given hypergraph H, calling:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">HG</span> <span class="o">=</span> <span class="n">hmod</span><span class="o">.</span><span class="n">precompute_attributes</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
</pre></div>
</div>
<p>will pre-compute quantities such as node strength (weighted degree), d-weights (total weight for each edge cardinality) and binomial coefficients.</p>
</section>
<section id="id1">
<h3>Modularity<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h3>
<p>Given hypergraph HG and a partition A of its vertices, hypergraph modularity is a measure of the quality of this partition.
Random partitions typically yield modularity near zero (it can be negative) while positive modularity is indicative of the presence
of dense communities, or modules. There are several variations for the definition of hypergraph modularity, and the main difference lies in the
weight given to different edges. Modularity is computed via:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">hmod</span><span class="o">.</span><span class="n">modularity</span><span class="p">(</span><span class="n">HG</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">wdc</span><span class="o">=</span><span class="n">linear</span><span class="p">)</span>
</pre></div>
</div>
<p>In a graph, an edge only links 2 nodes, so given partition A, an edge is either within a community (which increases the modularity)
or between communities.</p>
<p>With hypergraphs, we consider edges of size <em>d=2</em> or more. Given some vertex partition A and some <em>d</em>-edge <em>e</em>, let <em>c</em> be the number of nodes
that belong to the most represented part in <em>e</em>; if <em>c &gt; d/2</em>, we consider this edge to be within the part.
Hyper-parameters <em>0 &lt;= w(d,c) &lt;= 1</em> control the weight
given to such edges. Three functions are supplied in this submodule, namely:</p>
<dl class="simple">
<dt><strong>linear</strong></dt><dd><p><span class="math notranslate nohighlight">\(w(d,c) = c/d\)</span> if <span class="math notranslate nohighlight">\(c &gt; d/2\)</span>, else <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd>
<dt><strong>majority</strong></dt><dd><p><span class="math notranslate nohighlight">\(w(d,c) = 1\)</span> if <span class="math notranslate nohighlight">\(c &gt; d/2\)</span>, else <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd>
<dt><strong>strict</strong></dt><dd><p><span class="math notranslate nohighlight">\(w(d,c) = 1\)</span> if <span class="math notranslate nohighlight">\(c == d\)</span>, else <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd>
</dl>
<p>The ‘linear’ function is used by default. More details in [2].</p>
</section>
<section id="two-section-graph">
<h3>Two-section graph<a class="headerlink" href="#two-section-graph" title="Permalink to this heading"></a></h3>
<p>There are several good partitioning algorithms for graphs such as the Louvain algorithm and ECG, a consensus clustering algorithm.
One way to obtain a partition for hypergraph HG is to build its corresponding two-section graph G and run a graph clustering algorithm.
Code is provided to build such graph via:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="o">=</span> <span class="n">hmod</span><span class="o">.</span><span class="n">two_section</span><span class="p">(</span><span class="n">HG</span><span class="p">)</span>
</pre></div>
</div>
<p>which returns an igraph.Graph object.</p>
</section>
<section id="clustering-algorithms">
<h3>Clustering Algorithms<a class="headerlink" href="#clustering-algorithms" title="Permalink to this heading"></a></h3>
<p>Two clustering (vertex partitioning) algorithms are supplied. The first one is a hybrid method proposed by Kumar et al. (see [1])
that uses the Louvain algorithm on the two-section graph, but re-weights the edges according to the distibution of vertices
from each part inside each edge. Given hypergraph HG, this is called as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">K</span> <span class="o">=</span> <span class="n">hmod</span><span class="o">.</span><span class="n">kumar</span><span class="p">(</span><span class="n">HG</span><span class="p">)</span>
</pre></div>
</div>
<p>The other supplied algorithm is a simple method to improve hypergraph modularity directely. Given some
initial partition of the vertices (for example via Louvain on the two-section graph), move vertices between parts in order
to improve hypergraph modularity. Given hypergraph HG and initial partition A, this is called as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">L</span> <span class="o">=</span> <span class="n">hmod</span><span class="o">.</span><span class="n">last_step</span><span class="p">(</span><span class="n">HG</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">wdc</span><span class="o">=</span><span class="n">linear</span><span class="p">)</span>
</pre></div>
</div>
<p>where the ‘wdc’ parameter is the same as in the modularity function.</p>
</section>
<section id="other-features">
<h3>Other Features<a class="headerlink" href="#other-features" title="Permalink to this heading"></a></h3>
<p>We represent a vertex partition A  as a list of sets, but another conveninent representation is via a dictionary.
We provide two utility functions to switch representation, namely <cite>A = dict2part(D)</cite> and <cite>D = part2dict(A)</cite>.</p>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this heading"></a></h3>
<p>[1] Kumar T., Vaidyanathan S., Ananthapadmanabhan H., Parthasarathy S. and Ravindran B. “A New Measure of Modularity in Hypergraphs: Theoretical Insights and Implications for Effective Clustering”. In: Cherifi H., Gaito S., Mendes J., Moro E., Rocha L. (eds) Complex Networks and Their Applications VIII. COMPLEX NETWORKS 2019. Studies in Computational Intelligence, vol 881. Springer, Cham. <a class="reference external" href="https://doi.org/10.1007/978-3-030-36687-2_24">https://doi.org/10.1007/978-3-030-36687-2_24</a></p>
<p>[2] Kamiński B., Prałat P. and Théberge F. “Community Detection Algorithm Using Hypergraph Modularity”. In: Benito R.M., Cherifi C., Cherifi H., Moro E., Rocha L.M., Sales-Pardo M. (eds) Complex Networks &amp; Their Applications IX. COMPLEX NETWORKS 2020. Studies in Computational Intelligence, vol 943. Springer, Cham. <a class="reference external" href="https://doi.org/10.1007/978-3-030-65347-7_13">https://doi.org/10.1007/978-3-030-65347-7_13</a></p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="widget.html" class="btn btn-neutral float-left" title="Hypernetx-Widget" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="publications.html" class="btn btn-neutral float-right" title="Publications" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023 Battelle Memorial Institute.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>